!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ADDR_BITS	ftl.h	17;"	d
ADDR_BITS	ftl.h	21;"	d
AreAllFramesFull	hmb_lru.c	/^int AreAllFramesFull(hmb_Queue* queue)$/;"	f
BLKS_PER_PL	ftl.h	29;"	d
BLK_BITS	ftl.h	74;"	d
BM_START_SECTOR_NB	common.h	62;"	d
CHANNEL_BLOCKING	common.h	21;"	d
CHANNEL_IS_EMPTY	common.h	173;"	d
CHANNEL_IS_ERASE	common.h	176;"	d
CHANNEL_IS_READ	common.h	175;"	d
CHANNEL_IS_WRITE	common.h	174;"	d
CHIP_BLOCKING	common.h	22;"	d
CH_BITS	ftl.h	79;"	d
CH_OP	common.h	169;"	d
CLEAN	ftl.h	18;"	d
CLEAN	hash/hashftl.h	23;"	d
CLEAN	hashftl.h	1;"	d
COLD_RAN	common.h	164;"	d
COLD_RAN_WRITE	common.h	130;"	d
CONT_SEQ_WRITE	common.h	127;"	d
C__bm_empty_offset	hmb_types.h	/^	uint32_t C__bm_empty_offset;          \/* 4bytes (acc: 79) *\/$/;"	m	struct:HmbMeta
C__bm_empty_seg_id	hmb_types.h	/^	int16_t  C__bm_empty_seg_id;          \/* 2bytes (acc: 75) *\/$/;"	m	struct:HmbMeta
C__bm_empty_table_offset	hmb_types.h	/^	uint32_t C__bm_empty_table_offset;    \/* 4bytes (acc: 115) *\/$/;"	m	struct:HmbMeta
C__bm_empty_table_seg_id	hmb_types.h	/^	int16_t  C__bm_empty_table_seg_id;    \/* 2bytes (acc: 111) *\/$/;"	m	struct:HmbMeta
C__bm_offset	hmb_types.h	/^	uint32_t C__bm_offset;                \/* 4bytes (acc: 73) *\/$/;"	m	struct:HmbMeta
C__bm_parts_cnt	hmb_types.h	/^	uint32_t C__bm_parts_cnt;             \/* 4bytes (acc: 93) *\/$/;"	m	struct:HmbMeta
C__bm_seg_id	hmb_types.h	/^	int16_t  C__bm_seg_id;                \/* 2bytes (acc: 69) *\/$/;"	m	struct:HmbMeta
C__cache_unit_bits	hmb_types.h	/^	uint16_t C__cache_unit_bits;          \/* 2bytes (acc: 123) *\/$/;"	m	struct:HmbMeta
C__heads_ST_num	hmb_types.h	/^	uint16_t C__heads_ST_num;     \/* 2bytes (acc: 40) *\/$/;"	m	struct:HmbMeta
C__heads_ST_offset	hmb_types.h	/^	uint32_t C__heads_ST_offset;  \/* 4bytes (acc: 38) *\/$/;"	m	struct:HmbMeta
C__heads_ST_seg_id	hmb_types.h	/^	int16_t  C__heads_ST_seg_id;  \/* 2bytes (acc: 34) *\/$/;"	m	struct:HmbMeta
C__heads_ST_unit	hmb_types.h	/^	uint32_t C__heads_ST_unit;    \/* 4bytes (acc: 44) *\/$/;"	m	struct:HmbMeta
C__heads_cnt_max	hmb_types.h	/^	uint32_t C__heads_cnt_max;            \/* 4bytes (acc: 49) *\/$/;"	m	struct:HmbMeta
C__heads_hash_bit	hmb_types.h	/^	uint8_t  C__heads_hash_bit;           \/* 1byte  (acc: 45) *\/$/;"	m	struct:HmbMeta
C__n_cached	hmb_types.h	/^	uint32_t C__n_cached;                 \/* 4bytes (acc: 97) *\/$/;"	m	struct:HmbMeta
C__n_dirty	hmb_types.h	/^	uint32_t C__n_dirty;                  \/* 4bytes (acc: 101) *\/$/;"	m	struct:HmbMeta
C__n_max_entries	hmb_types.h	/^	uint32_t C__n_max_entries;            \/* 4bytes (acc: 32) *\/$/;"	m	struct:HmbMeta
C__pctg_explicitFlush	hmb_types.h	/^	uint16_t C__pctg_explicitFlush;       \/* 2bytes (acc: 103) *\/$/;"	m	struct:HmbMeta
C__sorted_ST_num	hmb_types.h	/^	uint16_t C__sorted_ST_num;    \/* 2bytes (acc: 57) *\/$/;"	m	struct:HmbMeta
C__sorted_ST_offset	hmb_types.h	/^	uint32_t C__sorted_ST_offset; \/* 4bytes (acc: 55) *\/$/;"	m	struct:HmbMeta
C__sorted_ST_seg_id	hmb_types.h	/^	int16_t  C__sorted_ST_seg_id; \/* 2bytes (acc: 51) *\/$/;"	m	struct:HmbMeta
C__sorted_ST_unit	hmb_types.h	/^	uint32_t C__sorted_ST_unit;   \/* 4bytes (acc: 61) *\/$/;"	m	struct:HmbMeta
C__table_ST_num	hmb_types.h	/^	uint16_t C__table_ST_num;     \/* 2bytes (acc: 24) *\/$/;"	m	struct:HmbMeta
C__table_ST_offset	hmb_types.h	/^	uint32_t C__table_ST_offset;  \/* 4bytes (acc: 22) *\/$/;"	m	struct:HmbMeta
C__table_ST_seg_id	hmb_types.h	/^	int16_t  C__table_ST_seg_id;  \/* 2bytes (acc: 18) *\/$/;"	m	struct:HmbMeta
C__table_ST_unit	hmb_types.h	/^	uint32_t C__table_ST_unit;    \/* 4bytes (acc: 28) *\/$/;"	m	struct:HmbMeta
C__table_bm_ST_offset	hmb_types.h	/^	uint32_t C__table_bm_ST_offset;       \/* 4bytes (acc: 121) *\/$/;"	m	struct:HmbMeta
C__table_bm_ST_seg_id	hmb_types.h	/^	int16_t  C__table_bm_ST_seg_id;       \/* 2bytes (acc: 117) *\/$/;"	m	struct:HmbMeta
C__urgency_offset	hmb_types.h	/^	uint32_t C__urgency_offset;           \/* 4bytes (acc: 89) *\/$/;"	m	struct:HmbMeta
C__urgency_seg_id	hmb_types.h	/^	int16_t  C__urgency_seg_id;           \/* 2bytes (acc: 85) *\/$/;"	m	struct:HmbMeta
C__victimAll_offset	hmb_types.h	/^	uint32_t C__victimAll_offset;         \/* 4bytes (acc: 67) *\/$/;"	m	struct:HmbMeta
C__victimAll_seg_id	hmb_types.h	/^	int16_t  C__victimAll_seg_id;         \/* 2bytes (acc: 63) *\/$/;"	m	struct:HmbMeta
C__victimRc_offset	hmb_types.h	/^	uint32_t C__victimRc_offset;          \/* 4bytes (acc: 109) *\/$/;"	m	struct:HmbMeta
C__victimRc_seg_id	hmb_types.h	/^	int16_t  C__victimRc_seg_id;          \/* 2bytes (acc: 105) *\/$/;"	m	struct:HmbMeta
DATA_BLOCK	common.h	143;"	d
DATA_R	hash/hashftl.h	18;"	d
DATA_W	hash/hashftl.h	19;"	d
DIRTY	ftl.h	19;"	d
DIRTY	hash/hashftl.h	24;"	d
DIRTY	hashftl.h	2;"	d
EMPTY_BLOCK	common.h	134;"	d
EMPTY_DATA_BLOCK	common.h	144;"	d
EMPTY_RAN_BLOCK	common.h	138;"	d
EMPTY_RAN_COLD_BLOCK	common.h	140;"	d
EMPTY_RAN_HOT_BLOCK	common.h	142;"	d
EMPTY_SEQ_BLOCK	common.h	136;"	d
ERASE	common.h	186;"	d
Enqueue	hmb_lru.c	/^int Enqueue(hmb_Queue* queue, hmb_Hash* hash, unsigned pageNumber)$/;"	f
FAIL	common.h	122;"	d
FEMU_DISABLE_DELAY_EMU	ftl.h	/^    FEMU_DISABLE_DELAY_EMU = 4,$/;"	e	enum:__anon4
FEMU_DISABLE_GC_DELAY	ftl.h	/^    FEMU_DISABLE_GC_DELAY = 2,$/;"	e	enum:__anon4
FEMU_DISABLE_LOG	ftl.h	/^    FEMU_DISABLE_LOG = 7,$/;"	e	enum:__anon4
FEMU_ENABLE_DELAY_EMU	ftl.h	/^    FEMU_ENABLE_DELAY_EMU = 3,$/;"	e	enum:__anon4
FEMU_ENABLE_GC_DELAY	ftl.h	/^    FEMU_ENABLE_GC_DELAY = 1,$/;"	e	enum:__anon4
FEMU_ENABLE_LOG	ftl.h	/^    FEMU_ENABLE_LOG = 6,$/;"	e	enum:__anon4
FEMU_RESET_ACCT	ftl.h	/^    FEMU_RESET_ACCT = 5,$/;"	e	enum:__anon4
FTL_free_mappings	hmb_types.h	/^	int FTL_free_mappings; $/;"	m	struct:HmbCtrl
FTL_mappings	hmb_types.h	/^	struct Hmb_FTL_MapInfo** FTL_mappings;$/;"	m	struct:HmbCtrl	typeref:struct:HmbCtrl::Hmb_FTL_MapInfo
GC_IO	ftl.h	/^    GC_IO = 1,$/;"	e	enum:__anon2
GC_ON	common.h	37;"	d
GC_ON	common.h	46;"	d
GC_ON	common.h	63;"	d
GC_R	hash/hashftl.h	20;"	d
GC_READ	common.h	187;"	d
GC_TRIGGER_OVERALL	common.h	38;"	d
GC_TRIGGER_OVERALL	common.h	47;"	d
GC_VICTIM_OVERALL	common.h	39;"	d
GC_W	hash/hashftl.h	21;"	d
GC_WRITE	common.h	188;"	d
HASH_FTL	ftl.h	11;"	d
HID_BITS	ftl.h	15;"	d
HMB_CONFIG_NUMBER_OF_TABLE_BITMAP_PARTS	hmb_config.h	8;"	d
HMB_CTRL	hmb.c	/^HmbCtrl HMB_CTRL;$/;"	v
HMB_DEBUG_TIME	hmb_utils.c	/^HmbDebugTime HMB_DEBUG_TIME;$/;"	v
HMB_DEBUG_TIME_PER_REQUEST	hmb_utils.c	/^HmbDebugTimePerRequest HMB_DEBUG_TIME_PER_REQUEST;$/;"	v
HMB_DEBUG__N_OVERFLOWED	hmb_debug.c	/^uint64_t HMB_DEBUG__N_OVERFLOWED = 0;$/;"	v
HMB_DEBUG__N_READ_PAGES	hmb_debug.c	/^uint64_t HMB_DEBUG__N_READ_PAGES = 0;$/;"	v
HMB_DEBUG__N_READ_REQUESTED_SECTORS	hmb_debug.c	/^uint64_t HMB_DEBUG__N_READ_REQUESTED_SECTORS = 0;$/;"	v
HMB_DEBUG__N_REQUESTS	hmb_debug.c	/^uint64_t HMB_DEBUG__N_REQUESTS = 0;$/;"	v
HMB_DEBUG__N_WRITE_REQUESTED_SECTORS	hmb_debug.c	/^uint64_t HMB_DEBUG__N_WRITE_REQUESTED_SECTORS = 0;$/;"	v
HMB_DEBUG__N_WRITTEN_PAGES	hmb_debug.c	/^uint64_t HMB_DEBUG__N_WRITTEN_PAGES = 0;$/;"	v
HMB_DEBUG__SUM_OVERFLOWED_TIME	hmb_debug.c	/^uint64_t HMB_DEBUG__SUM_OVERFLOWED_TIME = 0;$/;"	v
HMB_ENTRIES	hmb.h	5;"	d
HMB_FOR_READ	hmb_types.h	11;"	d
HMB_FOR_WRITE	hmb_types.h	12;"	d
HMB_HASH_MULTIPLIER	hmb_internal.h	61;"	d
HMB_HAS_NO_ENTRY	hmb_types.h	16;"	d
HMB_MAPINFO_NOT_MAPPED	hmb_internal.h	52;"	d
HMB_OFFSET_SEG0_METADATA	hmb_internal.h	42;"	d
HMB_OFFSET_SEG0_SEGENT_SPLIT_TABLE	hmb_internal.h	44;"	d
HMB_SEGENT_BITMAP_BITS_PER_PART	hmb_internal.h	54;"	d
HMB_SEGENT_BITMAP_PART_MAX_VALUE	hmb_internal.h	55;"	d
HMB_SEGENT_UNUSED	hmb_internal.h	50;"	d
HMB_SPACEMGMT_BASE_TIME	hmb_spaceMgmt.c	/^int64_t HMB_SPACEMGMT_BASE_TIME = HMB_HAS_NO_ENTRY;$/;"	v
HMB_SPACEMGMT_BITMAP_BITS_PER_PART	hmb_spaceMgmt.h	38;"	d
HMB_SPACEMGMT_BITMAP_PART_MAX_VALUE	hmb_spaceMgmt.h	39;"	d
HMB_SPACEMGMT_CTRL	hmb_spaceMgmt.c	/^HmbSpaceMgmtCtrl HMB_SPACEMGMT_CTRL;$/;"	v
HMB_SPACEMGMT_HASH_GOLDEN_RATIO_64	hmb_internal.h	60;"	d
HMB_SPACEMGMT_IMPLICIT_FLUSH_DURATION_NS	hmb_spaceMgmt.h	54;"	d
HMB_SPACEMGMT_IMPLICIT_FLUSH_RATIO	hmb_spaceMgmt.h	53;"	d
HMB_SPACEMGMT_LOCK	hmb_spaceMgmt.h	42;"	d
HMB_SPACEMGMT_UL_DISABLED	hmb_spaceMgmt.h	/^	HMB_SPACEMGMT_UL_DISABLED = 0,$/;"	e	enum:__anon7
HMB_SPACEMGMT_UL_HIGH	hmb_spaceMgmt.h	/^	HMB_SPACEMGMT_UL_HIGH   = 2,$/;"	e	enum:__anon7
HMB_SPACEMGMT_UL_LOW	hmb_spaceMgmt.h	/^	HMB_SPACEMGMT_UL_LOW    = 4,$/;"	e	enum:__anon7
HMB_SPACEMGMT_UL_MIDDLE	hmb_spaceMgmt.h	/^	HMB_SPACEMGMT_UL_MIDDLE = 3,$/;"	e	enum:__anon7
HMB_SPACEMGMT_UL_NUMBER	hmb_spaceMgmt.h	51;"	d
HMB_SPACEMGMT_UL_URGENT	hmb_spaceMgmt.h	/^	HMB_SPACEMGMT_UL_URGENT = 1,$/;"	e	enum:__anon7
HMB_SPACEMGMT_UL_WEIGHT	hmb_spaceMgmt.c	/^const uint32_t HMB_SPACEMGMT_UL_WEIGHT[] = {4, 3, 2, 1};$/;"	v
HMB_SPACEMGMT_UNLOCK	hmb_spaceMgmt.h	41;"	d
HMB_UL_NUMBER	hmb_types.h	14;"	d
HMB__SE_ST_num	hmb_types.h	/^	uint16_t HMB__SE_ST_num;      \/* 2bytes (acc: 6) *\/$/;"	m	struct:HmbMeta
HMB__SE_ST_offset	hmb_types.h	/^	uint32_t HMB__SE_ST_offset;   \/* 4bytes (acc: 16) *\/$/;"	m	struct:HmbMeta
HMB__SE_ST_seg_id	hmb_types.h	/^	int16_t  HMB__SE_ST_seg_id;   \/* 2bytes (acc: 12) *\/$/;"	m	struct:HmbMeta
HMB__SE_ST_unit	hmb_types.h	/^	uint32_t HMB__SE_ST_unit;     \/* 4bytes (acc: 10) *\/$/;"	m	struct:HmbMeta
HMB__SE_num_max	hmb_types.h	/^	uint32_t HMB__SE_num_max;             \/* 4bytes (acc: 4) *\/$/;"	m	struct:HmbMeta
HOT_RAN	common.h	165;"	d
HOT_RAN_WRITE	common.h	129;"	d
H_INVALID	hash/hashftl.h	26;"	d
H_INVALID	hashftl.h	4;"	d
H_OOB	ftl.h	/^} H_OOB;$/;"	t	typeref:struct:hash_OOB
H_OOB	hash/hashftl.h	/^} H_OOB;$/;"	t	typeref:struct:hash_OOB
H_VALID	hash/hashftl.h	25;"	d
H_VALID	hashftl.h	3;"	d
HmbBitmap32	hmb_types.h	/^typedef uint32_t HmbBitmap32;$/;"	t
HmbBitmapEmpty	hmb_types.h	/^typedef int32_t HmbBitmapEmpty;$/;"	t
HmbCtrl	hmb_types.h	/^typedef struct HmbCtrl {$/;"	s
HmbCtrl	hmb_types.h	/^} HmbCtrl;$/;"	t	typeref:struct:HmbCtrl
HmbDLL	hmb_types.h	/^typedef struct HmbDLL$/;"	s
HmbDLL	hmb_types.h	/^} HmbDLL;$/;"	t	typeref:struct:HmbDLL
HmbDebugTime	hmb_types.h	/^typedef struct HmbDebugTime$/;"	s
HmbDebugTime	hmb_types.h	/^} HmbDebugTime;$/;"	t	typeref:struct:HmbDebugTime
HmbDebugTimePerRequest	hmb_types.h	/^typedef struct HmbDebugTimePerRequest$/;"	s
HmbDebugTimePerRequest	hmb_types.h	/^} HmbDebugTimePerRequest;$/;"	t	typeref:struct:HmbDebugTimePerRequest
HmbEntry	hmb_types.h	/^typedef struct HmbEntry {$/;"	s
HmbEntry	hmb_types.h	/^} HmbEntry;$/;"	t	typeref:struct:HmbEntry
HmbHeads	hmb_types.h	/^typedef int32_t HmbHeads;$/;"	t
HmbHostAddr	hmb_types.h	/^typedef uint64_t HmbHostAddr;$/;"	t
HmbMapInfo	hmb_types.h	/^typedef struct HmbMapInfo$/;"	s
HmbMapInfo	hmb_types.h	/^} HmbMapInfo;$/;"	t	typeref:struct:HmbMapInfo
HmbMappedAddr	hmb_types.h	/^typedef struct HmbMappedAddr$/;"	s
HmbMappedAddr	hmb_types.h	/^} HmbMappedAddr;$/;"	t	typeref:struct:HmbMappedAddr
HmbMeta	hmb_types.h	/^typedef struct HmbMeta$/;"	s
HmbMeta	hmb_types.h	/^} HmbMeta;$/;"	t	typeref:struct:HmbMeta
HmbSeg	hmb_types.h	/^typedef struct HmbSeg$/;"	s
HmbSeg	hmb_types.h	/^} HmbSeg;$/;"	t	typeref:struct:HmbSeg
HmbSegEmpty	hmb_types.h	/^typedef struct HmbSegEmpty$/;"	s
HmbSegEmpty	hmb_types.h	/^} HmbSegEmpty;$/;"	t	typeref:struct:HmbSegEmpty
HmbSegEnt	hmb_types.h	/^typedef struct HmbSegEnt$/;"	s
HmbSegEnt	hmb_types.h	/^} HmbSegEnt;$/;"	t	typeref:struct:HmbSegEnt
HmbSharedBitmapEnt	hmb_types.h	/^typedef struct HmbSharedBitmapEnt$/;"	s
HmbSharedBitmapEnt	hmb_types.h	/^} HmbSharedBitmapEnt;$/;"	t	typeref:struct:HmbSharedBitmapEnt
HmbSharedEnt	hmb_types.h	/^typedef struct HmbSharedEnt$/;"	s
HmbSharedEnt	hmb_types.h	/^} HmbSharedEnt;$/;"	t	typeref:struct:HmbSharedEnt
HmbSortedEnt	hmb_types.h	/^typedef struct HmbSortedEnt$/;"	s
HmbSortedEnt	hmb_types.h	/^} HmbSortedEnt;$/;"	t	typeref:struct:HmbSortedEnt
HmbSpaceMgmtCtrl	hmb_types.h	/^typedef struct HmbSpaceMgmtCtrl$/;"	s
HmbSpaceMgmtCtrl	hmb_types.h	/^} HmbSpaceMgmtCtrl;$/;"	t	typeref:struct:HmbSpaceMgmtCtrl
HmbSplitTable	hmb_types.h	/^typedef struct HmbSplitTable$/;"	s
HmbSplitTable	hmb_types.h	/^} HmbSplitTable;$/;"	t	typeref:struct:HmbSplitTable
HmbSync	hmb_types.h	/^typedef int32_t HmbSync;$/;"	t
HmbTime	hmb_types.h	/^typedef struct HmbTime$/;"	s
HmbTime	hmb_types.h	/^} HmbTime;$/;"	t	typeref:struct:HmbTime
Hmb_FTL_MapInfo	hmb_types.h	/^typedef struct Hmb_FTL_MapInfo$/;"	s
Hmb_FTL_MapInfo	hmb_types.h	/^} Hmb_FTL_MapInfo;$/;"	t	typeref:struct:Hmb_FTL_MapInfo
INIT	common.h	157;"	d
INVALID	common.h	153;"	d
INVALID_LPN	ftl.h	7;"	d
INVALID_PPA	ftl.h	6;"	d
LATENCY_OP	common.h	171;"	d
LEFTROTATE	ftl.h	13;"	d
LEFTROTATE	md5.c	3;"	d	file:
LUNS_PER_CH	ftl.h	32;"	d
LUN_BITS	ftl.h	78;"	d
MAP_READ	common.h	201;"	d
MAP_WRITE	common.h	202;"	d
NAND_ERASE	ftl.h	/^    NAND_ERASE = 2,$/;"	e	enum:__anon1
NAND_ERASE_LATENCY	ftl.h	/^    NAND_ERASE_LATENCY = 2000000,$/;"	e	enum:__anon1
NAND_PROG_LATENCY	ftl.h	/^    NAND_PROG_LATENCY = 200000,$/;"	e	enum:__anon1
NAND_READ	ftl.h	/^    NAND_READ =  0,$/;"	e	enum:__anon1
NAND_READ_LATENCY	ftl.h	/^    NAND_READ_LATENCY = 40000,$/;"	e	enum:__anon1
NAND_WRITE	ftl.h	/^    NAND_WRITE = 1,$/;"	e	enum:__anon1
NCHS	ftl.h	33;"	d
NEW_RAN_WRITE	common.h	128;"	d
NEW_SEQ_WRITE	common.h	126;"	d
NOOP	common.h	183;"	d
OOB_RAM	hash/hashftl.h	/^	H_OOB OOB_RAM;$/;"	m	struct:SRAM
PGS_PER_BLK	ftl.h	28;"	d
PG_BITS	ftl.h	75;"	d
PG_FREE	ftl.h	/^    PG_FREE = 0,$/;"	e	enum:__anon3
PG_INVALID	ftl.h	/^    PG_INVALID = 1,$/;"	e	enum:__anon3
PG_VALID	ftl.h	/^    PG_VALID = 2$/;"	e	enum:__anon3
PLS_PER_LUN	ftl.h	31;"	d
PL_BITS	ftl.h	77;"	d
PRIMARY_TABLE	ftl.h	/^} PRIMARY_TABLE;$/;"	t	typeref:struct:primary_table
PRIMARY_TABLE	hash/hashftl.h	/^} PRIMARY_TABLE;$/;"	t	typeref:struct:primary_table
PTR_RAM	hash/hashftl.h	/^	PTR PTR_RAM;$/;"	m	struct:SRAM
QNode	ftl.h	/^typedef struct QNode {$/;"	s
QNode	ftl.h	/^} QNode;$/;"	t	typeref:struct:QNode
RAN_BLOCK	common.h	137;"	d
RAN_COLD_BLOCK	common.h	139;"	d
RAN_COLD_MERGE_READ	common.h	197;"	d
RAN_COLD_MERGE_WRITE	common.h	199;"	d
RAN_COLD_WRITE	common.h	191;"	d
RAN_HOT_BLOCK	common.h	141;"	d
RAN_HOT_MERGE_READ	common.h	198;"	d
RAN_HOT_MERGE_WRITE	common.h	200;"	d
RAN_HOT_WRITE	common.h	192;"	d
RAN_MERGE	common.h	159;"	d
RAN_MERGE_READ	common.h	194;"	d
RAN_MERGE_WRITE	common.h	196;"	d
RAN_WRITE	common.h	190;"	d
READ	common.h	184;"	d
REG_IS_EMPTY	common.h	178;"	d
REG_IS_ERASE	common.h	181;"	d
REG_IS_READ	common.h	180;"	d
REG_IS_WRITE	common.h	179;"	d
REG_OP	common.h	170;"	d
ReferencePage	hmb_lru.c	/^int ReferencePage(struct ssd *ssd, unsigned pageNumber)$/;"	f
SECSZ	ftl.h	25;"	d
SECS_PER_PAGE	ftl.h	26;"	d
SEC_BITS	ftl.h	76;"	d
SEC_FREE	ftl.h	/^    SEC_FREE = 0,$/;"	e	enum:__anon3
SEC_INVALID	ftl.h	/^    SEC_INVALID = 1,$/;"	e	enum:__anon3
SEC_VALID	ftl.h	/^    SEC_VALID = 2,$/;"	e	enum:__anon3
SEQ_BLOCK	common.h	135;"	d
SEQ_MERGE	common.h	158;"	d
SEQ_MERGE_READ	common.h	193;"	d
SEQ_MERGE_WRITE	common.h	195;"	d
SEQ_WRITE	common.h	189;"	d
SM__init_bitmap	hmb_types.h	/^	HmbTime SM__init_bitmap;$/;"	m	struct:HmbDebugTime
SM__init_entry	hmb_types.h	/^	HmbTime SM__init_entry;$/;"	m	struct:HmbDebugTime
SM__init_heads	hmb_types.h	/^	HmbTime SM__init_heads;$/;"	m	struct:HmbDebugTime
SM__init_insert_map_info	hmb_types.h	/^	HmbTime SM__init_insert_map_info;$/;"	m	struct:HmbDebugTime
SM__init_sorted	hmb_types.h	/^	HmbTime SM__init_sorted;$/;"	m	struct:HmbDebugTime
SRAM	hash/hashftl.h	/^typedef struct SRAM{$/;"	s
SRAM	hash/hashftl.h	/^} SRAM;$/;"	t	typeref:struct:SRAM
SRAM_load	hash/hashftl_util.c	/^value_set* SRAM_load(SRAM* sram, int32_t ppa, int idx){$/;"	f
SRAM_load	hashftl_util.c	/^value_set* SRAM_load(SRAM* sram, int32_t ppa, int idx){$/;"	f
SRAM_unload	hash/hashftl_util.c	/^void SRAM_unload(SRAM* sram, int32_t ppa, int idx){$/;"	f
SRAM_unload	hashftl_util.c	/^void SRAM_unload(SRAM* sram, int32_t ppa, int idx){$/;"	f
SUCCESS	common.h	121;"	d
TYPE	hash/hashftl.h	17;"	d
UNMAPPED_PPA	ftl.h	8;"	d
UPDATE_END_TIME	common.h	205;"	d
UPDATE_GC_END_TIME	common.h	207;"	d
UPDATE_GC_START_TIME	common.h	206;"	d
UPDATE_START_TIME	common.h	204;"	d
USER_IO	ftl.h	/^    USER_IO = 0,$/;"	e	enum:__anon2
VALID	common.h	152;"	d
VICTIM_INCHIP	common.h	148;"	d
VICTIM_NOPARAL	common.h	149;"	d
VICTIM_OVERALL	common.h	147;"	d
VIRTUAL_BLOCK_TABLE	ftl.h	/^} VIRTUAL_BLOCK_TABLE;$/;"	t	typeref:struct:virtual_block_table
VIRTUAL_BLOCK_TABLE	hash/hashftl.h	/^} VIRTUAL_BLOCK_TABLE;$/;"	t	typeref:struct:virtual_block_table
WHOLE_BLOCKING	common.h	20;"	d
WRITE	common.h	185;"	d
_COMMON_H_	common.h	9;"	d
__FEMU_FTL_H	ftl.h	2;"	d
__HMB_DEBUG_H__	hmb_debug.h	33;"	d
__H_HASHFTL__	hash/hashftl.h	2;"	d
__SSD__HMB_CONFIG_H__	hmb_config.h	2;"	d
__SSD__HMB_H__	hmb.h	3;"	d
__SSD__HMB_INTERNAL_H__	hmb_internal.h	30;"	d
__SSD__HMB_SPACEMGMT_H__	hmb_spaceMgmt.h	30;"	d
__SSD__HMB_TYPES_H__	hmb_types.h	2;"	d
__SSD__HMB_UTILS_H__	hmb_utils.h	2;"	d
__hashftl	hash/hashftl.c	/^algorithm __hashftl = {$/;"	v
_g_nob	hash/hashftl.c	/^int32_t _g_nob;				\/\/ number of block$/;"	v
_g_nop	hash/hashftl.c	/^int32_t _g_nop;				\/\/ number of page$/;"	v
_g_ppb	hash/hashftl.c	/^int32_t _g_ppb;				\/\/ page per block$/;"	v
addr	hmb_types.h	/^	HmbMappedAddr      addr;$/;"	m	struct:HmbMapInfo
addr	hmb_types.h	/^	HmbMappedAddr      addr;$/;"	m	struct:Hmb_FTL_MapInfo
addr	hmb_types.h	/^	uint64_t    addr; \/* 8bytes (acc: 8) *\/$/;"	m	struct:HmbEntry
addr_bits	ftl.h	/^	uint32_t addr_bits;$/;"	m	struct:ssd
alloc_page	hash/hashftl_util.c	/^int32_t alloc_page(int32_t lpa, int32_t* cal_ppid, int32_t* hid){$/;"	f
alloc_page	hashftl_util.c	/^int32_t alloc_page(int32_t lpa, int32_t* cal_ppid, int32_t* hid){$/;"	f
array	ftl.h	/^    QNode** array; \/\/ an array of queue nodes$/;"	m	struct:hmb_Hash
assign_pseudo_req	hash/hashftl_util.c	/^algo_req* assign_pseudo_req(TYPE type, value_set *temp_v, request *req){$/;"	f
assign_pseudo_req	hashftl_util.c	/^algo_req* assign_pseudo_req(TYPE type, value_set *temp_v, request *req){$/;"	f
b_heap	hash/hashftl.c	/^Heap *b_heap;$/;"	v
barray	ftl.h	/^	struct nand_block *barray;$/;"	m	struct:ssd	typeref:struct:ssd::nand_block
bb_admin_cmd	bb.c	/^static uint16_t bb_admin_cmd(FemuCtrl *n, NvmeCmd *cmd)$/;"	f	file:
bb_flip	bb.c	/^static void bb_flip(FemuCtrl *n, NvmeCmd *cmd)$/;"	f	file:
bb_init	bb.c	/^static void bb_init(FemuCtrl *n, Error **errp)$/;"	f	file:
bb_init_ctrl_str	bb.c	/^static void bb_init_ctrl_str(FemuCtrl *n)$/;"	f	file:
bb_io_cmd	bb.c	/^static uint16_t bb_io_cmd(FemuCtrl *n, NvmeNamespace *ns, NvmeCmd *cmd,$/;"	f	file:
bb_nvme_rw	bb.c	/^static uint16_t bb_nvme_rw(FemuCtrl *n, NvmeNamespace *ns, NvmeCmd *cmd,$/;"	f	file:
blk	ftl.h	/^            uint64_t blk : BLK_BITS;$/;"	m	struct:ppa::__anon5::__anon6
blk	ftl.h	/^    int blk;$/;"	m	struct:write_pointer
blk	ftl.h	/^    struct nand_block *blk;$/;"	m	struct:nand_plane	typeref:struct:nand_plane::nand_block
blk_er_lat	ftl.h	/^    int blk_er_lat;   \/* NAND block erase latency in nanoseconds *\/$/;"	m	struct:ssdparams
blk_erase_cnt	ftl.h	/^	int blk_erase_cnt; $/;"	m	struct:ssd
blk_id	ftl.h	/^	uint64_t blk_id;$/;"	m	struct:nand_block
blks_per_ch	ftl.h	/^    int blks_per_ch;  \/* # of blocks per channel *\/$/;"	m	struct:ssdparams
blks_per_line	ftl.h	/^    int blks_per_line;$/;"	m	struct:ssdparams
blks_per_lun	ftl.h	/^	int blks_per_lun; \/* # of blocks per LUN *\/$/;"	m	struct:ssdparams
blks_per_pl	ftl.h	/^    int blks_per_pl;  \/* # of blocks per plane *\/$/;"	m	struct:ssdparams
bm	hash/hashftl.c	/^BM_T *bm;$/;"	v
bm	hmb_types.h	/^	HmbMappedAddr *bm;$/;"	m	struct:HmbSpaceMgmtCtrl
bm_empty	hmb_types.h	/^	HmbMappedAddr *bm_empty;$/;"	m	struct:HmbSpaceMgmtCtrl
bm_empty_table	hmb_types.h	/^	HmbMappedAddr *bm_empty_table;$/;"	m	struct:HmbSpaceMgmtCtrl
bm_parts_cnt	hmb_types.h	/^	uint32_t  bm_parts_cnt;$/;"	m	struct:HmbSpaceMgmtCtrl
busy	ftl.h	/^    bool busy;$/;"	m	struct:nand_lun
busy	ftl.h	/^    bool busy;$/;"	m	struct:ssd_channel
cache_unit	hmb_types.h	/^	uint64_t cache_unit;$/;"	m	struct:HmbSpaceMgmtCtrl
cache_unit_bits	hmb_types.h	/^	uint8_t  cache_unit_bits;$/;"	m	struct:HmbSpaceMgmtCtrl
capacity	ftl.h	/^    int capacity; \/\/ how many pages can be there$/;"	m	struct:hmb_Hash
ch	ftl.h	/^	struct ssd_channel *ch;$/;"	m	struct:ssd	typeref:struct:ssd::ssd_channel
ch	ftl.h	/^            uint64_t ch  : CH_BITS;$/;"	m	struct:ppa::__anon5::__anon6
ch	ftl.h	/^    int ch;$/;"	m	struct:write_pointer
ch_xfer_lat	ftl.h	/^    int ch_xfer_lat;  \/* channel transfer latency for one page in nanoseconds$/;"	m	struct:ssdparams
check_addr	ftl.c	/^static inline void check_addr(int a, int max)$/;"	f	file:
check_params	ftl.c	/^static void check_params(struct ssdparams *spp)$/;"	f	file:
check_written	hash/hashftl_util.c	/^int32_t check_written( int32_t	pba, int32_t lpa, int32_t* cal_ppid)$/;"	f
check_written	hashftl.c	/^static struct ppa check_written(struct ssd *ssd, int32_t pba)$/;"	f	file:
check_written	hashftl_util.c	/^int32_t check_written( int32_t	pba, int32_t lpa, int32_t* cal_ppid)$/;"	f
clean_one_block	ftl.c	/^void clean_one_block(struct ssd *ssd, struct ppa *ppa)$/;"	f
cmd	ftl.h	/^    int cmd;$/;"	m	struct:nand_cmd
count	ftl.h	/^    unsigned count; \/\/ Number of filled frames$/;"	m	struct:hmb_Queue
createHash	hmb_lru.c	/^hmb_Hash* createHash(int capacity)$/;"	f
createQueue	hmb_lru.c	/^hmb_Queue* createQueue(int numberOfFrames)$/;"	f
curline	ftl.h	/^    struct line *curline;$/;"	m	struct:write_pointer	typeref:struct:write_pointer::line
dataplane_started_ptr	ftl.h	/^    bool *dataplane_started_ptr;$/;"	m	struct:ssd
deQueue	hmb_lru.c	/^void deQueue(hmb_Queue* queue)$/;"	f
dev_pci	hmb_types.h	/^    void *dev_pci;$/;"	m	struct:HmbCtrl
dirty	hmb_types.h	/^	uint64_t dirty  :  1;  $/;"	m	struct:HmbSharedEnt
do_gc	ftl.c	/^static int do_gc(struct ssd *ssd, bool force)$/;"	f	file:
e_next	hmb_types.h	/^	int32_t e_next;$/;"	m	struct:HmbDLL
e_next	hmb_types.h	/^	uint32_t e_next;		\/* 4bytes (acc: 20) *\/$/;"	m	struct:HmbSharedEnt
e_next	hmb_types.h	/^	uint32_t e_next;$/;"	m	struct:HmbSortedEnt
e_own	hmb_types.h	/^	uint32_t e_own;			\/* 4bytes (acc: 12) *\/$/;"	m	struct:HmbSharedEnt
e_own	hmb_types.h	/^	uint32_t e_own;$/;"	m	struct:HmbSortedEnt
e_prev	hmb_types.h	/^	int32_t e_prev;$/;"	m	struct:HmbDLL
e_prev	hmb_types.h	/^	uint32_t e_prev;		\/* 4bytes (acc: 16) *\/$/;"	m	struct:HmbSharedEnt
e_prev	hmb_types.h	/^	uint32_t e_prev;$/;"	m	struct:HmbSortedEnt
empty_list	hmb_types.h	/^	struct HmbSegEmpty *empty_list; \/* previously, "empty_list"*\/$/;"	m	struct:HmbSeg	typeref:struct:HmbSeg::HmbSegEmpty
enable_gc_delay	ftl.h	/^    bool enable_gc_delay;$/;"	m	struct:ssdparams
enable_hmb	hmb_types.h	/^	bool     enable_hmb;     \/* HMB: Enable Host Memory (from dword 11) *\/$/;"	m	struct:HmbCtrl
entry	ftl.h	/^    QTAILQ_ENTRY(line) entry; \/* in either {free,victim,full} list *\/$/;"	m	struct:line
entry_id	hmb_types.h	/^	int32_t			   entry_id; $/;"	m	struct:Hmb_FTL_MapInfo
entry_id	hmb_types.h	/^	int32_t            entry_id;$/;"	m	struct:HmbMapInfo
erase_cnt	ftl.h	/^    int erase_cnt;$/;"	m	struct:nand_block
filled	hmb_types.h	/^	HmbBitmap32 filled;$/;"	m	struct:HmbSharedBitmapEnt
free_b	hash/hashftl.c	/^b_queue *free_b;$/;"	v
free_line_cnt	ftl.h	/^    int free_line_cnt;$/;"	m	struct:line_mgmt
free_line_list	ftl.h	/^    QTAILQ_HEAD(free_line_list, line) free_line_list;$/;"	m	struct:line_mgmt
front	ftl.h	/^    QNode *front, *rear;$/;"	m	struct:hmb_Queue
ftl_assert	ftl.h	349;"	d
ftl_assert	ftl.h	351;"	d
ftl_debug	ftl.h	333;"	d
ftl_debug	ftl.h	336;"	d
ftl_err	ftl.h	340;"	d
ftl_log	ftl.h	343;"	d
ftl_thread	ftl.c	/^static void *ftl_thread(void *arg)$/;"	f	file:
ftl_thread	ftl.h	/^    QemuThread ftl_thread;$/;"	m	struct:ssd
full_line_cnt	ftl.h	/^    int full_line_cnt;$/;"	m	struct:line_mgmt
full_line_list	ftl.h	/^    QTAILQ_HEAD(full_line_list, line) full_line_list;$/;"	m	struct:line_mgmt
g	ftl.h	/^        } g;$/;"	m	union:ppa::__anon5	typeref:struct:ppa::__anon5::__anon6
gc_count	hash/hashftl.c	/^int32_t gc_count;			\/\/ number of total gc$/;"	v
gc_endtime	ftl.h	/^    uint64_t gc_endtime;$/;"	m	struct:nand_lun
gc_endtime	ftl.h	/^    uint64_t gc_endtime;$/;"	m	struct:ssd_channel
gc_load	hash/hashftl.c	/^int32_t gc_load;$/;"	v
gc_pri	hash/hashftl.c	/^int32_t gc_pri;$/;"	v
gc_read_page	ftl.c	/^static void gc_read_page(struct ssd *ssd, struct ppa *ppa)$/;"	f	file:
gc_thres_lines	ftl.h	/^    int gc_thres_lines;$/;"	m	struct:ssdparams
gc_thres_lines_high	ftl.h	/^    int gc_thres_lines_high;$/;"	m	struct:ssdparams
gc_thres_pcent	ftl.h	/^    double gc_thres_pcent;$/;"	m	struct:ssdparams
gc_thres_pcent_high	ftl.h	/^    double gc_thres_pcent_high;$/;"	m	struct:ssdparams
gc_val	hash/hashftl.c	/^int32_t gc_val;$/;"	v
gc_write_page	ftl.c	/^static uint64_t gc_write_page(struct ssd *ssd, struct ppa *old_ppa)$/;"	f	file:
gc_write_page_hash	ftl.c	/^static uint64_t gc_write_page_hash(struct ssd *ssd, struct ppa *old_ppa, struct nand_block *new_blk)$/;"	f	file:
get_blk	ftl.c	/^struct nand_block *get_blk(struct ssd *ssd, struct ppa *ppa)$/;"	f
get_ch	ftl.c	/^static inline struct ssd_channel *get_ch(struct ssd *ssd, struct ppa *ppa)$/;"	f	file:
get_hash	hmb_lru.c	/^static inline hmb_Hash *get_hash(struct ssd *ssd) $/;"	f	file:
get_line	ftl.c	/^static inline struct line *get_line(struct ssd *ssd, struct ppa *ppa)$/;"	f	file:
get_lun	ftl.c	/^struct nand_lun *get_lun(struct ssd *ssd, struct ppa *ppa)$/;"	f
get_maptbl_ent	ftl.c	/^static inline struct ppa get_maptbl_ent(struct ssd *ssd, uint64_t lpn)$/;"	f	file:
get_new_page	ftl.c	/^static struct ppa get_new_page(struct ssd *ssd)$/;"	f	file:
get_new_page_hash	hashftl.c	/^struct ppa get_new_page_hash(struct ssd *ssd, int32_t lpa) $/;"	f
get_next_free_line	ftl.c	/^static struct line *get_next_free_line(struct ssd *ssd)$/;"	f	file:
get_pg	ftl.c	/^static inline struct nand_page *get_pg(struct ssd *ssd, struct ppa *ppa)$/;"	f	file:
get_pl	ftl.c	/^static inline struct nand_plane *get_pl(struct ssd *ssd, struct ppa *ppa)$/;"	f	file:
get_queue	hmb_lru.c	/^static inline hmb_Queue *get_queue(struct ssd *ssd) $/;"	f	file:
get_rmap_ent	ftl.c	/^static inline uint64_t get_rmap_ent(struct ssd *ssd, struct ppa *ppa)$/;"	f	file:
get_vba_from_md5	hash/hashftl_util.c	/^int32_t get_vba_from_md5(uint64_t md5_result, int32_t hid){$/;"	f
get_vba_from_md5	hashftl.c	/^static int32_t get_vba_from_md5(uint64_t md5_result, int32_t hid){$/;"	f	file:
get_vba_from_md5	hashftl_util.c	/^int32_t get_vba_from_md5(uint64_t md5_result, int32_t hid){$/;"	f
get_vba_from_table	hash/hashftl_util.c	/^int32_t get_vba_from_table(struct ssd * ssd, struct ppa * ppa, int32_t lpa){$/;"	f
get_vba_from_table	hashftl.c	/^static int32_t get_vba_from_table(struct ssd * ssd, struct ppa * ppa, int32_t lpa) {$/;"	f	file:
get_vba_from_table	hashftl_util.c	/^int32_t get_vba_from_table(int32_t lpa){$/;"	f
hash_OOB	ftl.h	/^	H_OOB *hash_OOB;$/;"	m	struct:ssd
hash_OOB	ftl.h	/^typedef struct hash_OOB{$/;"	s
hash_OOB	hash/hashftl.c	/^H_OOB *hash_OOB;$/;"	v
hash_OOB	hash/hashftl.h	/^typedef struct hash_OOB{$/;"	s
hash_create	hash/hashftl.c	/^uint32_t hash_create(lower_info *li, algorithm *algo){$/;"	f
hash_destroy	hash/hashftl.c	/^void hash_destroy(lower_info *li, algorithm *algo){$/;"	f
hash_end_req	hash/hashftl.c	/^void *hash_end_req(algo_req* input){$/;"	f
hash_garbage_collection	hash/hashftl_gc.c	/^int32_t hash_garbage_collection(int32_t pba, int32_t vba){$/;"	f
hash_garbage_collection	hashftl.c	/^static int hash_garbage_collection(struct ssd *ssd, uint32_t max_pba, uint32_t max_vba) {$/;"	f	file:
hash_garbage_collection	hashftl_gc.c	/^int32_t hash_garbage_collection(int32_t pba, int32_t vba){$/;"	f
hash_get	hash/hashftl.c	/^uint32_t hash_get(request* const req){$/;"	f
hash_mutex	hash/hashftl.h	/^	dl_sync hash_mutex;$/;"	m	struct:hash_params
hash_params	hash/hashftl.h	/^typedef struct hash_params{$/;"	s
hash_params	hash/hashftl.h	/^} hash_params;$/;"	t	typeref:struct:hash_params
hash_read	hashftl.c	/^int hash_read(struct ssd *ssd, struct ppa *ppa, uint64_t lpn) {$/;"	f
hash_remove	hash/hashftl.c	/^uint32_t hash_remove(request* const req){$/;"	f
hash_set	hash/hashftl.c	/^uint32_t hash_set(request* const req){$/;"	f
heads_ST_mapped	hmb_types.h	/^	HmbMappedAddr* heads_ST_mapped;$/;"	m	struct:HmbSpaceMgmtCtrl
heads_ST_size	hmb_types.h	/^	uint64_t       heads_ST_size;$/;"	m	struct:HmbSpaceMgmtCtrl
heads_cnt	hmb_types.h	/^	uint32_t heads_cnt;$/;"	m	struct:HmbSpaceMgmtCtrl
heads_hash_bit	hmb_types.h	/^	uint8_t  heads_hash_bit; \/* for hashing: # hash bits *\/$/;"	m	struct:HmbSpaceMgmtCtrl
heads_split_mapped	hmb_types.h	/^	HmbMappedAddr** heads_split_mapped;$/;"	m	struct:HmbSpaceMgmtCtrl
heads_split_num	hmb_types.h	/^	uint16_t        heads_split_num;$/;"	m	struct:HmbSpaceMgmtCtrl
heads_split_unit	hmb_types.h	/^	uint32_t        heads_split_unit;$/;"	m	struct:HmbSpaceMgmtCtrl
hid	ftl.h	/^	int32_t hid; $/;"	m	struct:ppa
hid	ftl.h	/^	int32_t hid;$/;"	m	struct:primary_table
hid	hash/hashftl.h	/^	int32_t hid;$/;"	m	struct:primary_table
hid_secondary	ftl.h	/^	int32_t hid_secondary; $/;"	m	struct:ssd
hid_secondary	hash/hashftl.c	/^int32_t hid_secondary;        \/\/ hid that indicate mapping is at secondary table$/;"	v
hmb_FTL_mapInfo_delete	hmb_internal.c	/^bool hmb_FTL_mapInfo_delete(Hmb_FTL_MapInfo *target)$/;"	f
hmb_FTL_mapInfo_free	hmb_internal.c	/^void hmb_FTL_mapInfo_free(Hmb_FTL_MapInfo *target)$/;"	f
hmb_FTL_mapInfo_get_hashed_idx_by_mapped_addr	hmb_internal.c	/^int64_t hmb_FTL_mapInfo_get_hashed_idx_by_mapped_addr(HmbMappedAddr *addr)$/;"	f
hmb_FTL_mapInfo_get_hashed_idx_by_obj	hmb_internal.c	/^int64_t hmb_FTL_mapInfo_get_hashed_idx_by_obj(Hmb_FTL_MapInfo *target)$/;"	f
hmb_FTL_mapInfo_insert	hmb_internal.c	/^bool hmb_FTL_mapInfo_insert(Hmb_FTL_MapInfo *target)$/;"	f
hmb_FTL_mapInfo_new	hmb_internal.c	/^Hmb_FTL_MapInfo *hmb_FTL_mapInfo_new(void)$/;"	f
hmb_FTL_mapInfo_search	hmb_internal.c	/^Hmb_FTL_MapInfo *hmb_FTL_mapInfo_search(HmbMappedAddr *addr)$/;"	f
hmb_Hash	ftl.h	/^typedef struct hmb_Hash {$/;"	s
hmb_Hash	ftl.h	/^} hmb_Hash;$/;"	t	typeref:struct:hmb_Hash
hmb_Queue	ftl.h	/^typedef struct hmb_Queue {$/;"	s
hmb_Queue	ftl.h	/^} hmb_Queue;$/;"	t	typeref:struct:hmb_Queue
hmb_cache_bm	ftl.h	/^	int *hmb_cache_bm;  \/* hmb cache 4kb unit *\/	$/;"	m	struct:ssd
hmb_cached	ftl.c	/^static inline uint8_t hmb_cached(struct ssd *ssd, int entry)$/;"	f	file:
hmb_calloc	hmb.c	/^HmbMappedAddr *hmb_calloc(uint64_t size)$/;"	f
hmb_debug	hmb_debug.h	57;"	d
hmb_debug_file_name	hmb_debug.c	/^bool hmb_debug_file_name(const char *idx, const char *format_filename, ...)$/;"	f
hmb_enable	hmb.c	/^bool hmb_enable(uint32_t page_size, uint32_t dw11,$/;"	f
hmb_free	hmb.c	/^void hmb_free(HmbMappedAddr *addr)$/;"	f
hmb_get_max_allocable_size_byte	hmb_internal.c	/^int64_t hmb_get_max_allocable_size_byte(void)$/;"	f
hmb_get_segEnt_by_id	hmb_internal.c	/^HmbSegEnt *hmb_get_segEnt_by_id(bool for_write, int32_t id)$/;"	f
hmb_get_seg_by_id	hmb_internal.c	/^HmbSeg *hmb_get_seg_by_id(int32_t id)$/;"	f
hmb_get_total_allocable_size_byte	hmb_internal.c	/^int64_t hmb_get_total_allocable_size_byte(void)$/;"	f
hmb_gettid	hmb_debug.c	/^pid_t hmb_gettid(void)$/;"	f
hmb_hashing	hmb_internal.c	/^uint32_t hmb_hashing(uint64_t value, uint8_t bits)$/;"	f
hmb_init	hmb.c	/^bool hmb_init(void *dev_pci, void *nvme_ctrl)$/;"	f
hmb_init_structure	hmb.c	/^bool hmb_init_structure(void)$/;"	f
hmb_is_addr_remapped	hmb_internal.c	/^bool hmb_is_addr_remapped; \/* extern-ed in "hmb_internal.h" *\/$/;"	v
hmb_is_reallocated	hmb.c	/^bool hmb_is_reallocated;$/;"	v
hmb_lpas_per_blk	ftl.h	/^	int hmb_lpas_per_blk;  \/* total # of lpas can be cached to a HMB block*\/$/;"	m	struct:ssdparams
hmb_lru_hash	ftl.h	/^	hmb_Hash* hmb_lru_hash;$/;"	m	struct:ssd
hmb_lru_list	ftl.h	/^	hmb_Queue* hmb_lru_list;$/;"	m	struct:ssd
hmb_malloc	hmb.c	/^HmbMappedAddr *hmb_malloc(uint64_t size)$/;"	f
hmb_mapInfo_delete	hmb_internal.c	/^bool hmb_mapInfo_delete(HmbMapInfo *target)$/;"	f
hmb_mapInfo_free	hmb_internal.c	/^void hmb_mapInfo_free(HmbMapInfo *target)$/;"	f
hmb_mapInfo_get_hashed_idx_by_mapped_addr	hmb_internal.c	/^int64_t hmb_mapInfo_get_hashed_idx_by_mapped_addr(HmbMappedAddr *addr)$/;"	f
hmb_mapInfo_get_hashed_idx_by_obj	hmb_internal.c	/^int64_t hmb_mapInfo_get_hashed_idx_by_obj(HmbMapInfo *target)$/;"	f
hmb_mapInfo_init	hmb_internal.c	/^bool hmb_mapInfo_init(uint64_t n)$/;"	f
hmb_mapInfo_insert	hmb_internal.c	/^bool hmb_mapInfo_insert(HmbMapInfo *target)$/;"	f
hmb_mapInfo_new	hmb_internal.c	/^HmbMapInfo *hmb_mapInfo_new(void)$/;"	f
hmb_mapInfo_search	hmb_internal.c	/^HmbMapInfo *hmb_mapInfo_search(HmbMappedAddr *addr)$/;"	f
hmb_meta_get	hmb_internal.c	/^HmbMeta *hmb_meta_get(bool for_write)$/;"	f
hmb_meta_init	hmb_internal.c	/^bool hmb_meta_init(void)$/;"	f
hmb_printf	hmb_debug.c	/^void hmb_printf(const char *file, int line, const char *func, const char *format, ...)$/;"	f
hmb_read	hmb_internal.c	/^bool hmb_read(HmbHostAddr host_addr, void *dev_addr, uint64_t len)$/;"	f
hmb_segEmpty_delete	hmb_internal.c	/^bool hmb_segEmpty_delete(HmbSeg *segment, HmbSegEmpty *target)$/;"	f
hmb_segEmpty_emptying	hmb_internal.c	/^bool hmb_segEmpty_emptying(HmbSeg *segment, uint32_t offset, uint32_t size)$/;"	f
hmb_segEmpty_filling	hmb_internal.c	/^bool hmb_segEmpty_filling(HmbSeg *segment, HmbSegEmpty *target, uint32_t size)$/;"	f
hmb_segEmpty_free	hmb_internal.c	/^void hmb_segEmpty_free(HmbSegEmpty *target)$/;"	f
hmb_segEmpty_get_head	hmb_internal.c	/^HmbSegEmpty *hmb_segEmpty_get_head(HmbSeg *segment)$/;"	f
hmb_segEmpty_insert	hmb_internal.c	/^bool hmb_segEmpty_insert(HmbSeg *segment, HmbSegEmpty *target)$/;"	f
hmb_segEmpty_insert_tail	hmb_internal.c	/^bool hmb_segEmpty_insert_tail(HmbSeg *segment, HmbSegEmpty *target)$/;"	f
hmb_segEmpty_new	hmb_internal.c	/^HmbSegEmpty *hmb_segEmpty_new(void)$/;"	f
hmb_segEmpty_search	hmb_internal.c	/^HmbSegEmpty *hmb_segEmpty_search(uint32_t offset)$/;"	f
hmb_segEmpty_search_max	hmb_internal.c	/^HmbSegEmpty *hmb_segEmpty_search_max(void)$/;"	f
hmb_segEmpty_search_proper	hmb_internal.c	/^HmbSegEmpty *hmb_segEmpty_search_proper(uint64_t size)$/;"	f
hmb_segEmpty_set_head	hmb_internal.c	/^bool hmb_segEmpty_set_head(HmbSeg *segment, HmbSegEmpty *target)$/;"	f
hmb_segEnt_ST_get_by_idx	hmb_internal.c	/^HmbSplitTable *hmb_segEnt_ST_get_by_idx(bool for_write, int16_t idx)$/;"	f
hmb_segEnt_bm_empty_delete	hmb_internal.c	/^bool hmb_segEnt_bm_empty_delete(uint32_t idx)$/;"	f
hmb_segEnt_bm_empty_get_by_idx	hmb_internal.c	/^HmbDLL* hmb_segEnt_bm_empty_get_by_idx(uint32_t idx)$/;"	f
hmb_segEnt_bm_empty_get_head	hmb_internal.c	/^int32_t* hmb_segEnt_bm_empty_get_head(void)$/;"	f
hmb_segEnt_bm_empty_insert	hmb_internal.c	/^bool hmb_segEnt_bm_empty_insert(uint32_t idx)$/;"	f
hmb_segEnt_bm_empty_set_head	hmb_internal.c	/^bool hmb_segEnt_bm_empty_set_head(uint32_t idx)$/;"	f
hmb_segEnt_bm_fill_overflowed	hmb_internal.c	/^bool hmb_segEnt_bm_fill_overflowed(uint32_t from, uint32_t to)$/;"	f
hmb_segEnt_bm_get_empty	hmb_internal.c	/^bool hmb_segEnt_bm_get_empty(uint32_t *val)$/;"	f
hmb_segEnt_bm_set	hmb_internal.c	/^bool hmb_segEnt_bm_set(bool enable, uint32_t val)$/;"	f
hmb_segEnt_get_max_cnt	hmb_internal.c	/^uint32_t hmb_segEnt_get_max_cnt(void)$/;"	f
hmb_segEnt_get_new_id	hmb_internal.c	/^int32_t hmb_segEnt_get_new_id(void)$/;"	f
hmb_segEnt_init	hmb_internal.c	/^bool hmb_segEnt_init(void)$/;"	f
hmb_seg_init	hmb_internal.c	/^bool hmb_seg_init(void)$/;"	f
hmb_seg_init_empty	hmb_internal.c	/^bool hmb_seg_init_empty(HmbSeg *segment)$/;"	f
hmb_seg_update_max_allocable_size	hmb_internal.c	/^bool hmb_seg_update_max_allocable_size(HmbSeg *segment)$/;"	f
hmb_spaceMgmt_RCOnly_sorted_delete	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RCOnly_sorted_delete(uint32_t idx)$/;"	f
hmb_spaceMgmt_RCOnly_sorted_get_head_idx	hmb_spaceMgmt.c	/^int32_t hmb_spaceMgmt_RCOnly_sorted_get_head_idx(void)$/;"	f
hmb_spaceMgmt_RCOnly_sorted_insert_tail	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RCOnly_sorted_insert_tail(uint32_t idx)$/;"	f
hmb_spaceMgmt_RCOnly_sorted_set_head	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RCOnly_sorted_set_head(uint32_t idx)$/;"	f
hmb_spaceMgmt_RC_caching	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RC_caching(uint64_t lpn, uint32_t n_lb, bool do_data_copy, int64_t *expire_time)$/;"	f
hmb_spaceMgmt_RC_evict	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RC_evict(uint32_t n_evict, int64_t *expire_time)$/;"	f
hmb_spaceMgmt_RC_evict_LRU	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RC_evict_LRU(uint32_t n_evict, int64_t *expire_time)$/;"	f
hmb_spaceMgmt_RC_reorder	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RC_reorder(uint32_t idx)$/;"	f
hmb_spaceMgmt_RC_reorder_LRU	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RC_reorder_LRU(uint32_t idx)$/;"	f
hmb_spaceMgmt_RC_sorted_delete	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RC_sorted_delete(uint32_t idx)$/;"	f
hmb_spaceMgmt_RC_sorted_get_head_idx	hmb_spaceMgmt.c	/^int32_t hmb_spaceMgmt_RC_sorted_get_head_idx(void)$/;"	f
hmb_spaceMgmt_RC_sorted_insert_after	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RC_sorted_insert_after(uint32_t idx, uint32_t idx_after)$/;"	f
hmb_spaceMgmt_RC_sorted_insert_tail	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RC_sorted_insert_tail(uint32_t idx)$/;"	f
hmb_spaceMgmt_RC_sorted_set_head	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RC_sorted_set_head(uint32_t idx)$/;"	f
hmb_spaceMgmt_RC_update	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RC_update(uint32_t idx)$/;"	f
hmb_spaceMgmt_RC_update_LRU	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_RC_update_LRU(uint32_t idx)$/;"	f
hmb_spaceMgmt_WB_flush	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_WB_flush(uint32_t n_lb, void *_ssd, int64_t *expire_time)$/;"	f
hmb_spaceMgmt_WB_flush_explicit	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_WB_flush_explicit(uint32_t n_lb, void *ssd, int64_t *expire_time)$/;"	f
hmb_spaceMgmt_WB_flush_implicit	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_WB_flush_implicit(void *ssd, int64_t *expire_time)$/;"	f
hmb_spaceMgmt_WB_flusher	hmb_spaceMgmt.c	/^void hmb_spaceMgmt_WB_flusher(void *opaque)$/;"	f
hmb_spaceMgmt_WB_sorted_delete	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_WB_sorted_delete(int32_t urgency, uint32_t idx)$/;"	f
hmb_spaceMgmt_WB_sorted_delete_head	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_WB_sorted_delete_head(int32_t urgency)$/;"	f
hmb_spaceMgmt_WB_sorted_get_head	hmb_spaceMgmt.c	/^int32_t* hmb_spaceMgmt_WB_sorted_get_head(bool for_write, int32_t urgency)$/;"	f
hmb_spaceMgmt_WB_sorted_get_head_idx	hmb_spaceMgmt.c	/^int32_t hmb_spaceMgmt_WB_sorted_get_head_idx(int32_t urgency)$/;"	f
hmb_spaceMgmt_WB_sorted_insert_tail	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_WB_sorted_insert_tail(int32_t urgency, uint32_t idx)$/;"	f
hmb_spaceMgmt_WB_sorted_set_head	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_WB_sorted_set_head(int32_t urgency, uint32_t idx)$/;"	f
hmb_spaceMgmt_bm_empty_delete	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_bm_empty_delete(uint32_t idx)$/;"	f
hmb_spaceMgmt_bm_empty_get_by_idx	hmb_spaceMgmt.c	/^HmbDLL *hmb_spaceMgmt_bm_empty_get_by_idx(bool for_write, uint32_t idx)$/;"	f
hmb_spaceMgmt_bm_empty_get_head	hmb_spaceMgmt.c	/^int32_t *hmb_spaceMgmt_bm_empty_get_head(bool for_write)$/;"	f
hmb_spaceMgmt_bm_empty_insert	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_bm_empty_insert(uint32_t idx) $/;"	f
hmb_spaceMgmt_bm_empty_set_head	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_bm_empty_set_head(uint32_t idx)$/;"	f
hmb_spaceMgmt_bm_fill_overflowed	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_bm_fill_overflowed(uint32_t from, uint32_t to)$/;"	f
hmb_spaceMgmt_bm_get_empty	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_bm_get_empty(uint32_t *val)$/;"	f
hmb_spaceMgmt_bm_init	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_bm_init(uint32_t n_parts)$/;"	f
hmb_spaceMgmt_bm_set	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_bm_set(bool enable, uint32_t val)$/;"	f
hmb_spaceMgmt_debug_ssd_delay_state	hmb_spaceMgmt.c	/^void hmb_spaceMgmt_debug_ssd_delay_state(void)$/;"	f
hmb_spaceMgmt_entry_init	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_entry_init(void)$/;"	f
hmb_spaceMgmt_hash_calc_bits	hmb_spaceMgmt.c	/^uint8_t hmb_spaceMgmt_hash_calc_bits(uint32_t max_entries)$/;"	f
hmb_spaceMgmt_hash_verify	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_hash_verify(uint32_t idx)$/;"	f
hmb_spaceMgmt_heads_ST_get_by_idx	hmb_spaceMgmt.c	/^HmbSplitTable *hmb_spaceMgmt_heads_ST_get_by_idx(bool for_write, uint32_t idx)$/;"	f
hmb_spaceMgmt_heads_get_by_idx	hmb_spaceMgmt.c	/^HmbHeads *hmb_spaceMgmt_heads_get_by_idx(bool for_write, uint32_t idx)$/;"	f
hmb_spaceMgmt_heads_get_size	hmb_spaceMgmt.c	/^uint32_t hmb_spaceMgmt_heads_get_size(void)$/;"	f
hmb_spaceMgmt_heads_init	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_heads_init(uint8_t n_bits)$/;"	f
hmb_spaceMgmt_heap_rw	hmb_spaceMgmt.c	/^void hmb_spaceMgmt_heap_rw(bool is_write, uint64_t offset, uint64_t len, void *buf)$/;"	f
hmb_spaceMgmt_init	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_init(void)$/;"	f
hmb_spaceMgmt_init_cache_unit	hmb_spaceMgmt.c	/^void hmb_spaceMgmt_init_cache_unit(uint32_t cache_unit)$/;"	f
hmb_spaceMgmt_lba_to_lpn	hmb_spaceMgmt.c	/^uint64_t hmb_spaceMgmt_lba_to_lpn(uint64_t lba)$/;"	f
hmb_spaceMgmt_lock	hmb_spaceMgmt.c	/^void hmb_spaceMgmt_lock(void)$/;"	f
hmb_spaceMgmt_lpn_to_bytes	hmb_spaceMgmt.c	/^uint64_t hmb_spaceMgmt_lpn_to_bytes(uint64_t lpn)$/;"	f
hmb_spaceMgmt_lpn_to_lba	hmb_spaceMgmt.c	/^uint64_t hmb_spaceMgmt_lpn_to_lba(uint64_t lpn)$/;"	f
hmb_spaceMgmt_mappedAddr_get_by_idx	hmb_spaceMgmt.c	/^void *hmb_spaceMgmt_mappedAddr_get_by_idx(bool for_write, uint32_t idx)$/;"	f
hmb_spaceMgmt_mappedAddr_get_by_lpn	hmb_spaceMgmt.c	/^void *hmb_spaceMgmt_mappedAddr_get_by_lpn(bool for_write, uint32_t lpn)$/;"	f
hmb_spaceMgmt_nlb_to_nlp	hmb_spaceMgmt.c	/^uint32_t hmb_spaceMgmt_nlb_to_nlp(uint32_t n_lb, uint64_t slba)$/;"	f
hmb_spaceMgmt_nlp_to_nlb	hmb_spaceMgmt.c	/^uint32_t hmb_spaceMgmt_nlp_to_nlb(uint32_t n_lp)$/;"	f
hmb_spaceMgmt_shared_delete_by_idx	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_shared_delete_by_idx(uint32_t idx)$/;"	f
hmb_spaceMgmt_shared_get_head_by_lpn	hmb_spaceMgmt.c	/^HmbSharedEnt *hmb_spaceMgmt_shared_get_head_by_lpn(bool for_write, uint64_t lpn)$/;"	f
hmb_spaceMgmt_shared_get_new_entry_idx	hmb_spaceMgmt.c	/^int32_t hmb_spaceMgmt_shared_get_new_entry_idx(uint64_t lpn)$/;"	f
hmb_spaceMgmt_shared_insert	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_shared_insert(uint32_t idx)$/;"	f
hmb_spaceMgmt_shared_insert_LRU	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_shared_insert_LRU(uint32_t idx)$/;"	f
hmb_spaceMgmt_shared_insert_after	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_shared_insert_after(uint32_t idx, uint32_t idx_after)$/;"	f
hmb_spaceMgmt_shared_insert_tail	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_shared_insert_tail(uint32_t idx)$/;"	f
hmb_spaceMgmt_shared_is_reusable_by_idx	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_shared_is_reusable_by_idx(uint32_t idx)$/;"	f
hmb_spaceMgmt_shared_is_reusable_by_lpn	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_shared_is_reusable_by_lpn(uint64_t lpn)$/;"	f
hmb_spaceMgmt_shared_set_dirty	hmb_spaceMgmt.c	/^void hmb_spaceMgmt_shared_set_dirty(bool to_dirty, uint32_t idx)$/;"	f
hmb_spaceMgmt_shared_set_enable	hmb_spaceMgmt.c	/^void hmb_spaceMgmt_shared_set_enable(bool enable, uint32_t idx)$/;"	f
hmb_spaceMgmt_shared_set_head	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_shared_set_head(uint32_t idx)$/;"	f
hmb_spaceMgmt_sorted_ST_get_by_idx	hmb_spaceMgmt.c	/^HmbSplitTable *hmb_spaceMgmt_sorted_ST_get_by_idx(bool for_write, uint32_t idx)$/;"	f
hmb_spaceMgmt_sorted_get_by_idx	hmb_spaceMgmt.c	/^HmbSortedEnt *hmb_spaceMgmt_sorted_get_by_idx(bool for_write, uint32_t idx)$/;"	f
hmb_spaceMgmt_sorted_init	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_sorted_init(uint32_t n_parts)$/;"	f
hmb_spaceMgmt_table_ST_get_by_idx	hmb_spaceMgmt.c	/^HmbSplitTable *hmb_spaceMgmt_table_ST_get_by_idx(bool for_write, uint32_t idx)$/;"	f
hmb_spaceMgmt_table_bm_ST_get_by_idx	hmb_spaceMgmt.c	/^HmbSplitTable *hmb_spaceMgmt_table_bm_ST_get_by_idx(bool for_write, uint32_t idx)$/;"	f
hmb_spaceMgmt_table_bm_fill_overflowed	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_table_bm_fill_overflowed(uint32_t idx, uint32_t from, uint32_t to)$/;"	f
hmb_spaceMgmt_table_bm_get_by_idx	hmb_spaceMgmt.c	/^HmbSharedBitmapEnt *hmb_spaceMgmt_table_bm_get_by_idx(bool for_write, uint32_t idx)$/;"	f
hmb_spaceMgmt_table_bm_isCached_fully	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_table_bm_isCached_fully(uint32_t idx)$/;"	f
hmb_spaceMgmt_table_bm_isCached_partially	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_table_bm_isCached_partially(uint32_t idx, uint32_t idx_internal)$/;"	f
hmb_spaceMgmt_table_bm_set	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_table_bm_set(bool enable, uint32_t idx, uint32_t idx_internal)$/;"	f
hmb_spaceMgmt_table_bm_set_fully	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_table_bm_set_fully(bool enable, uint32_t idx)$/;"	f
hmb_spaceMgmt_table_get_by_idx	hmb_spaceMgmt.c	/^HmbSharedEnt *hmb_spaceMgmt_table_get_by_idx(bool for_write, uint32_t idx)$/;"	f
hmb_spaceMgmt_table_get_by_lpn	hmb_spaceMgmt.c	/^HmbSharedEnt *hmb_spaceMgmt_table_get_by_lpn(bool for_write, uint64_t lpn)$/;"	f
hmb_spaceMgmt_table_get_cache_num	hmb_spaceMgmt.c	/^uint32_t hmb_spaceMgmt_table_get_cache_num(void)$/;"	f
hmb_spaceMgmt_table_is_full	hmb_spaceMgmt.c	/^bool hmb_spaceMgmt_table_is_full(void)$/;"	f
hmb_spaceMgmt_table_max_entries	hmb_spaceMgmt.c	/^uint32_t hmb_spaceMgmt_table_max_entries(void)$/;"	f
hmb_spaceMgmt_table_nCached_inc	hmb_spaceMgmt.c	/^void hmb_spaceMgmt_table_nCached_inc(bool is_inc)$/;"	f
hmb_spaceMgmt_table_nDirty_inc	hmb_spaceMgmt.c	/^void hmb_spaceMgmt_table_nDirty_inc(bool is_inc)$/;"	f
hmb_spaceMgmt_unlock	hmb_spaceMgmt.c	/^void hmb_spaceMgmt_unlock(void)$/;"	f
hmb_spaceMgmt_victimAll_get	hmb_spaceMgmt.c	/^int32_t *hmb_spaceMgmt_victimAll_get(bool for_write)$/;"	f
hmb_spaceMgmt_victimRc_get	hmb_spaceMgmt.c	/^int32_t *hmb_spaceMgmt_victimRc_get(bool for_write)$/;"	f
hmb_timeDbg_get_time_ns	hmb_utils.c	/^uint64_t hmb_timeDbg_get_time_ns(HmbTime *t)$/;"	f
hmb_timeDbg_get_time_s	hmb_utils.c	/^double hmb_timeDbg_get_time_s(HmbTime *t)$/;"	f
hmb_timeDbg_record	hmb_utils.c	/^void hmb_timeDbg_record(HmbTime *t, bool is_start)$/;"	f
hmb_timeDbg_time	hmb_utils.c	/^uint64_t hmb_timeDbg_time(void)$/;"	f
hmb_tkill	hmb_debug.c	/^bool hmb_tkill(int tid, int sig)$/;"	f
hmb_write	hmb_internal.c	/^bool hmb_write(HmbHostAddr host_addr, void *dev_addr, uint64_t len)$/;"	f
host_addr	hmb_types.h	/^	HmbHostAddr        host_addr;$/;"	m	struct:HmbSeg
id	ftl.h	/^    int id;  \/* line id, the same as corresponding block id *\/$/;"	m	struct:line
id	hmb_types.h	/^	int16_t            id; $/;"	m	struct:HmbSeg
id	hmb_types.h	/^	int32_t  id;		 \/* 4bytes (acc: 4) *\/$/;"	m	struct:HmbSegEnt
init_hmb_LRU_hash	hmb_lru.c	/^hmb_Hash* init_hmb_LRU_hash(int available_FTL_entries) {$/;"	f
init_hmb_LRU_list	hmb_lru.c	/^hmb_Queue* init_hmb_LRU_list(int num_hmb_entries) {$/;"	f
inited	hmb_types.h	/^	bool inited;$/;"	m	struct:HmbSpaceMgmtCtrl
ipc	ftl.h	/^    int ipc; \/* invalid page count *\/$/;"	m	struct:nand_block
ipc	ftl.h	/^    int ipc; \/* invalid page count in this line *\/$/;"	m	struct:line
isQueueEmpty	hmb_lru.c	/^int isQueueEmpty(hmb_Queue* queue)$/;"	f
lba_end	hmb_types.h	/^	int32_t            lba_end; $/;"	m	struct:Hmb_FTL_MapInfo
lba_start	hmb_types.h	/^	int32_t            lba_start;$/;"	m	struct:Hmb_FTL_MapInfo
line	ftl.h	/^typedef struct line {$/;"	s
line	ftl.h	/^} line;$/;"	t	typeref:struct:line
line_mgmt	ftl.h	/^struct line_mgmt {$/;"	s
lines	ftl.h	/^    struct line *lines;$/;"	m	struct:line_mgmt	typeref:struct:line_mgmt::line
list	hmb_types.h	/^	struct HmbEntry **list;  \/* HMB entries **\/$/;"	m	struct:HmbCtrl	typeref:struct:HmbCtrl::HmbEntry
list_addr	hmb_types.h	/^	uint64_t list_addr;      \/* HMB: Full address of the list *\/$/;"	m	struct:HmbCtrl
list_addr_l	hmb_types.h	/^	uint32_t list_addr_l;    \/* HMB: Host Memory Descriptor List Lower Address (from dword 13) *\/$/;"	m	struct:HmbCtrl
list_addr_u	hmb_types.h	/^	uint32_t list_addr_u;    \/* HMB: Host Memory Descriptor List Upper Address (from dword 14) *\/$/;"	m	struct:HmbCtrl
list_cnt	hmb_types.h	/^	uint32_t list_cnt;       \/* HMB: Host Memory Descriptor List Entry Count (from dword 15)*\/$/;"	m	struct:HmbCtrl
ll__calc_max_allocable_size	hmb_types.h	/^	HmbTime ll__calc_max_allocable_size;$/;"	m	struct:HmbDebugTime
ll__ctrl_malloc	hmb_types.h	/^	HmbTime ll__ctrl_malloc;$/;"	m	struct:HmbDebugTime
ll__get_id	hmb_types.h	/^	HmbTime ll__get_id;$/;"	m	struct:HmbDebugTime
ll__get_new_id	hmb_types.h	/^	HmbTime ll__get_new_id;$/;"	m	struct:HmbDebugTime
ll__insert_entry	hmb_types.h	/^	HmbTime ll__insert_entry;$/;"	m	struct:HmbDebugTime
ll__map_pci	hmb_types.h	/^	HmbTime ll__map_pci;$/;"	m	struct:HmbDebugTime
ll__memset	hmb_types.h	/^	HmbTime ll__memset;$/;"	m	struct:HmbDebugTime
ll__search_empty_space	hmb_types.h	/^	HmbTime ll__search_empty_space;$/;"	m	struct:HmbDebugTime
ll__search_map_info	hmb_types.h	/^	HmbTime ll__search_map_info;$/;"	m	struct:HmbDebugTime
lm	ftl.h	/^    struct line_mgmt lm;$/;"	m	struct:ssd	typeref:struct:ssd::line_mgmt
lock	hmb_types.h	/^	int32_t  lock;                        \/* 4bytes (acc: 83) *\/$/;"	m	struct:HmbMeta
lpa	ftl.h	/^	int32_t lpa; $/;"	m	struct:hash_OOB
lpa	hash/hashftl.h	/^	int32_t lpa;$/;"	m	struct:hash_OOB
lpa_sft	ftl.h	/^	int32_t lpa_sft;$/;"	m	struct:ssd
lpa_sft	hash/hashftl.c	/^int32_t lpa_sft;$/;"	v
lpn	hmb_types.h	/^	uint64_t lpn    : 55;	\/* 8bytes (acc: 28) *\/$/;"	m	struct:HmbSharedEnt
lun	ftl.h	/^            uint64_t lun : LUN_BITS;$/;"	m	struct:ppa::__anon5::__anon6
lun	ftl.h	/^    int lun;$/;"	m	struct:write_pointer
lun	ftl.h	/^    struct nand_lun *lun;$/;"	m	struct:ssd_channel	typeref:struct:ssd_channel::nand_lun
luns_per_ch	ftl.h	/^    int luns_per_ch;  \/* # of LUNs per channel *\/$/;"	m	struct:ssdparams
map_for_gc	hash/hashftl_util.c	/^int32_t map_for_gc(int32_t lpa, int32_t ppa, int32_t ppid){$/;"	f
map_for_gc	hashftl_util.c	/^int32_t map_for_gc(int32_t lpa, int32_t ppa, int32_t ppid){$/;"	f
mapped_ppa	ftl.c	/^static inline bool mapped_ppa(struct ppa *ppa)$/;"	f	file:
mappings	hmb_types.h	/^	struct HmbMapInfo** mappings;$/;"	m	struct:HmbCtrl	typeref:struct:HmbCtrl::HmbMapInfo
mappings_bits	hmb_types.h	/^	uint8_t             mappings_bits;$/;"	m	struct:HmbCtrl
mappings_hashed_max	hmb_types.h	/^	uint64_t            mappings_hashed_max;$/;"	m	struct:HmbCtrl
maptbl	ftl.h	/^	struct ppa *maptbl; \/* page level mapping table *\/$/;"	m	struct:ssd	typeref:struct:ssd::ppa
maptbl_hash	ftl.h	/^	struct ppa_hash *maptbl_hash; \/* page level mapping table *\/$/;"	m	struct:ssd	typeref:struct:ssd::ppa_hash
mark_block_free	ftl.c	/^void mark_block_free(struct ssd *ssd, struct ppa *ppa)$/;"	f
mark_line_free	ftl.c	/^void mark_line_free(struct ssd *ssd, struct ppa *ppa)$/;"	f
mark_page_invalid	ftl.c	/^static void mark_page_invalid(struct ssd *ssd, struct ppa *ppa)$/;"	f	file:
mark_page_valid	ftl.c	/^static void mark_page_valid(struct ssd *ssd, struct ppa *ppa)$/;"	f	file:
md5	md5.c	/^void md5(uint32_t *initial_msg, size_t initial_len, uint64_t* result)$/;"	f
md5_u	hashftl.c	/^static uint64_t md5_u(uint32_t *initial_msg, size_t initial_len)$/;"	f	file:
md5_u	md5.c	/^uint64_t  md5_u(uint32_t *initial_msg, size_t initial_len)$/;"	f
mem_ret	hmb_types.h	/^	bool     mem_ret;        \/* HMB: Memory Return (from dword 11) *\/$/;"	m	struct:HmbCtrl
meta_host	hmb_types.h	/^	HmbHostAddr   meta_host;$/;"	m	struct:HmbCtrl
meta_mapped	hmb_types.h	/^	HmbMappedAddr meta_mapped;$/;"	m	struct:HmbCtrl
meta_mapped_size	hmb_types.h	/^	uint64_t      meta_mapped_size;$/;"	m	struct:HmbCtrl
mp_rd_lat	ftl.h	/^    int mp_rd_lat;    \/* NAND mapping read latency in nanoseconds *\/$/;"	m	struct:ssdparams
nand_block	ftl.h	/^struct nand_block {$/;"	s
nand_cmd	ftl.h	/^struct nand_cmd {$/;"	s
nand_lun	ftl.h	/^struct nand_lun {$/;"	s
nand_page	ftl.h	/^struct nand_page {$/;"	s
nand_plane	ftl.h	/^struct nand_plane {$/;"	s
nand_sec_status_t	ftl.h	/^typedef int nand_sec_status_t;$/;"	t
nblks	ftl.h	/^    int nblks;$/;"	m	struct:nand_plane
nchs	ftl.h	/^    int nchs;         \/* # of channels in the SSD *\/$/;"	m	struct:ssdparams
newQNode	hmb_lru.c	/^QNode* newQNode(unsigned pageNumber) {$/;"	f
next	ftl.h	/^    struct QNode *prev, *next;$/;"	m	struct:QNode	typeref:struct:QNode::
next	hmb_types.h	/^	struct HmbMapInfo* next;$/;"	m	struct:HmbMapInfo	typeref:struct:HmbMapInfo::HmbMapInfo
next	hmb_types.h	/^	struct HmbSegEmpty *prev, *next;$/;"	m	struct:HmbSegEmpty	typeref:struct:HmbSegEmpty::
next	hmb_types.h	/^ 	struct Hmb_FTL_MapInfo* next;$/;"	m	struct:Hmb_FTL_MapInfo	typeref:struct:Hmb_FTL_MapInfo::Hmb_FTL_MapInfo
next_ch_avail_time	ftl.h	/^    uint64_t next_ch_avail_time;$/;"	m	struct:ssd_channel
next_lun_avail_time	ftl.h	/^    uint64_t next_lun_avail_time;$/;"	m	struct:nand_lun
nluns	ftl.h	/^    int nluns;$/;"	m	struct:ssd_channel
npgs	ftl.h	/^    int npgs;$/;"	m	struct:nand_block
npls	ftl.h	/^    int npls;$/;"	m	struct:nand_lun
nr_hmb_cache	ftl.h	/^	uint32_t nr_hmb_cache;$/;"	m	struct:ssd
nsecs	ftl.h	/^    int nsecs;$/;"	m	struct:nand_page
num_GC	ftl.h	/^	int num_GC; $/;"	m	struct:ssd
num_GCcopy	ftl.h	/^	int num_GCcopy; $/;"	m	struct:ssd
num_copy	hash/hashftl.c	/^int32_t num_copy;$/;"	v
num_hid	ftl.h	/^	int32_t num_hid; $/;"	m	struct:ssd
num_hid	hash/hashftl.c	/^int32_t num_hid;              \/\/ number of hid bits$/;"	v
num_page_off	hash/hashftl.c	/^int32_t num_page_off;          \/\/ number of page offset bits$/;"	v
num_ppid	ftl.h	/^	int32_t num_ppid;$/;"	m	struct:ssd
num_ppid	hash/hashftl.c	/^int32_t num_ppid;             \/\/ number of ppid bits$/;"	v
num_val_victim	hash/hashftl.c	/^int32_t num_val_victim[300];	\/\/victim block valid page count$/;"	v
num_vbt	ftl.h	/^	int32_t num_vbt;$/;"	m	struct:ssd
num_vbt	hash/hashftl.c	/^int32_t num_vbt;$/;"	v
num_write	hash/hashftl.c	/^int32_t num_write;$/;"	v
numberOfFrames	ftl.h	/^    unsigned numberOfFrames; \/\/ total number of frames$/;"	m	struct:hmb_Queue
nvme_flush_from_hmb	hmb_spaceMgmt.c	/^bool nvme_flush_from_hmb(void *nvmeReq)$/;"	f
nvme_register_bbssd	bb.c	/^int nvme_register_bbssd(FemuCtrl *n)$/;"	f
of_femu	hmb_types.h	/^	HmbTime of_femu;$/;"	m	struct:HmbDebugTimePerRequest
of_femu__get_empty_block	hmb_types.h	/^	HmbTime of_femu__get_empty_block;$/;"	m	struct:HmbDebugTimePerRequest
of_hmb	hmb_types.h	/^	HmbTime of_hmb;$/;"	m	struct:HmbDebugTimePerRequest
of_hmb__RC_caching	hmb_types.h	/^	HmbTime of_hmb__RC_caching;$/;"	m	struct:HmbDebugTimePerRequest
of_hmb__bm_op	hmb_types.h	/^	HmbTime of_hmb__bm_op;$/;"	m	struct:HmbDebugTimePerRequest
of_hmb__delete	hmb_types.h	/^	HmbTime of_hmb__delete;$/;"	m	struct:HmbDebugTimePerRequest
of_hmb__flush	hmb_types.h	/^	HmbTime of_hmb__flush;$/;"	m	struct:HmbDebugTimePerRequest
of_hmb__insert	hmb_types.h	/^	HmbTime of_hmb__insert;$/;"	m	struct:HmbDebugTimePerRequest
of_hmb__memcpy	hmb_types.h	/^	HmbTime of_hmb__memcpy;$/;"	m	struct:HmbDebugTimePerRequest
of_hmb__table_get_by_lpn	hmb_types.h	/^	HmbTime of_hmb__table_get_by_lpn;$/;"	m	struct:HmbDebugTimePerRequest
of_qemu__iov	hmb_types.h	/^	HmbTime of_qemu__iov;$/;"	m	struct:HmbDebugTimePerRequest
of_qemu__memcpy	hmb_types.h	/^	HmbTime of_qemu__memcpy;$/;"	m	struct:HmbDebugTimePerRequest
of_qemu__sglist	hmb_types.h	/^	HmbTime of_qemu__sglist;$/;"	m	struct:HmbDebugTimePerRequest
offset	hmb_types.h	/^	uint32_t offset;		\/* 4bytes (acc: 8) *\/$/;"	m	struct:HmbSharedEnt
offset	hmb_types.h	/^	uint32_t offset;     \/* 4bytes (acc: 10) *\/$/;"	m	struct:HmbSegEnt
offset	hmb_types.h	/^	uint32_t offset;$/;"	m	struct:HmbSplitTable
offset_from	hmb_types.h	/^	uint32_t           offset_from;$/;"	m	struct:HmbSegEmpty
offset_to	hmb_types.h	/^	uint32_t           offset_to;$/;"	m	struct:HmbSegEmpty
pageNumber	ftl.h	/^    unsigned pageNumber; \/\/ the page number stored in this QNode$/;"	m	struct:QNode
page_size	hmb_types.h	/^	uint32_t page_size;$/;"	m	struct:HmbCtrl
parent	hmb_types.h	/^	void    *parent;		 \/* for NvmeCtrl **\/$/;"	m	struct:HmbCtrl
parent_ns	hmb_types.h	/^	void    *parent_ns;		 \/* for NvmeNamespace **\/$/;"	m	struct:HmbCtrl
pba	ftl.h	/^	int32_t pba;$/;"	m	struct:virtual_block_table
pba	hash/hashftl.h	/^	int32_t pba;$/;"	m	struct:virtual_block_table
pg	ftl.h	/^	struct nand_page *pg;$/;"	m	struct:nand_block	typeref:struct:nand_block::nand_page
pg	ftl.h	/^            uint64_t pg  : PG_BITS;$/;"	m	struct:ppa::__anon5::__anon6
pg	ftl.h	/^    int pg;$/;"	m	struct:write_pointer
pg_rd_lat	ftl.h	/^    int pg_rd_lat;    \/* NAND page read latency in nanoseconds *\/$/;"	m	struct:ssdparams
pg_wr_lat	ftl.h	/^    int pg_wr_lat;    \/* NAND page program latency in nanoseconds *\/$/;"	m	struct:ssdparams
pgs_per_blk	ftl.h	/^    int pgs_per_blk;  \/* # of NAND pages per block *\/$/;"	m	struct:ssdparams
pgs_per_ch	ftl.h	/^    int pgs_per_ch;   \/* # of pages per channel *\/$/;"	m	struct:ssdparams
pgs_per_line	ftl.h	/^    int pgs_per_line;$/;"	m	struct:ssdparams
pgs_per_lun	ftl.h	/^    int pgs_per_lun;  \/* # of pages per LUN (Die) *\/$/;"	m	struct:ssdparams
pgs_per_pl	ftl.h	/^    int pgs_per_pl;   \/* # of pages per plane *\/$/;"	m	struct:ssdparams
pl	ftl.h	/^            uint64_t pl  : PL_BITS;$/;"	m	struct:ppa::__anon5::__anon6
pl	ftl.h	/^    int pl;$/;"	m	struct:write_pointer
pl	ftl.h	/^    struct nand_plane *pl;$/;"	m	struct:nand_lun	typeref:struct:nand_lun::nand_plane
pls_per_ch	ftl.h	/^    int pls_per_ch;   \/* # of planes per channel *\/$/;"	m	struct:ssdparams
pls_per_lun	ftl.h	/^    int pls_per_lun;  \/* # of planes per LUN (Die) *\/$/;"	m	struct:ssdparams
pos	ftl.h	/^    size_t                  pos;$/;"	m	struct:line
ppa	ftl.h	/^	int32_t ppa;$/;"	m	struct:primary_table
ppa	ftl.h	/^        uint64_t ppa;$/;"	m	union:ppa::__anon5
ppa	ftl.h	/^struct ppa {$/;"	s
ppa	hash/hashftl.h	/^	int32_t ppa;$/;"	m	struct:primary_table
ppa2pgidx	ftl.c	/^static uint64_t ppa2pgidx(struct ssd *ssd, struct ppa *ppa)$/;"	f	file:
ppa_hash	ftl.h	/^	uint64_t ppa_hash;$/;"	m	struct:ppa
ppid	ftl.h	/^	int32_t ppid;$/;"	m	struct:ppa
ppid	ftl.h	/^	int32_t ppid;$/;"	m	struct:primary_table
ppid	hash/hashftl.h	/^	int32_t ppid;$/;"	m	struct:primary_table
prev	ftl.h	/^    struct QNode *prev, *next;$/;"	m	struct:QNode	typeref:struct:QNode::QNode
prev	hmb_types.h	/^	struct HmbMapInfo* prev;$/;"	m	struct:HmbMapInfo	typeref:struct:HmbMapInfo::HmbMapInfo
prev	hmb_types.h	/^	struct HmbSegEmpty *prev, *next;$/;"	m	struct:HmbSegEmpty	typeref:struct:HmbSegEmpty::HmbSegEmpty
prev	hmb_types.h	/^	struct Hmb_FTL_MapInfo* prev;$/;"	m	struct:Hmb_FTL_MapInfo	typeref:struct:Hmb_FTL_MapInfo::Hmb_FTL_MapInfo
pri_table	ftl.h	/^	PRIMARY_TABLE *pri_table;$/;"	m	struct:ssd
pri_table	hash/hashftl.c	/^PRIMARY_TABLE *pri_table;$/;"	v
primary_table	ftl.h	/^typedef struct primary_table{$/;"	s
primary_table	hash/hashftl.h	/^typedef struct primary_table{$/;"	s
print_algo_log	hash/hashftl.c	/^static void print_algo_log() {$/;"	f	file:
r	hmb_types.h	/^	void *r;$/;"	m	struct:HmbMappedAddr
r_e_next	hmb_types.h	/^	uint32_t r_e_next;$/;"	m	struct:HmbSortedEnt
r_e_prev	hmb_types.h	/^	uint32_t r_e_prev;$/;"	m	struct:HmbSortedEnt
re_gc_count	hash/hashftl.c	/^int32_t re_gc_count;		\/\/ number of gc due to remap$/;"	v
re_number	hash/hashftl.c	/^int32_t re_number;$/;"	v
re_page_count	hash/hashftl.c	/^int32_t re_page_count;		\/\/ number of moved page during remap$/;"	v
read_end	hash/hashftl.c	/^struct timeval read_end[3000000];$/;"	v	typeref:struct:timeval
read_latency_t	hash/hashftl.c	/^int32_t read_latency_t[10000];$/;"	v
read_start	hash/hashftl.c	/^struct timeval read_start[3000000];$/;"	v	typeref:struct:timeval
read_time	hash/hashftl.c	/^struct timeval read_time;$/;"	v	typeref:struct:timeval
rear	ftl.h	/^    QNode *front, *rear;$/;"	m	struct:hmb_Queue
reserved	ftl.h	/^	bool reserved; \/\/ reserved blk$/;"	m	struct:nand_block
reserved	ftl.h	/^	struct nand_block reserved;$/;"	m	struct:ssd	typeref:struct:ssd::nand_block
reserved	hash/hashftl.c	/^Block *reserved;$/;"	v
reserved_pba	hash/hashftl.c	/^int32_t reserved_pba;$/;"	v
rmap	ftl.h	/^	uint64_t *rmap;     \/* reverse mapptbl, assume it's stored in OOB *\/$/;"	m	struct:ssd
rsv	ftl.h	/^            uint64_t rsv : 1;$/;"	m	struct:ppa::__anon5::__anon6
rsvd	hmb_types.h	/^	uint32_t    rsvd; \/* 4bytes (acc: 16) *\/$/;"	m	struct:HmbEntry
rsvd	hmb_types.h	/^	uint64_t rsvd   :  4;  $/;"	m	struct:HmbSharedEnt
rsvd	hmb_types.h	/^	uint8_t  rsvd[5];                     \/* 5bytes (acc: 128) *\/$/;"	m	struct:HmbMeta
sec	ftl.h	/^            uint64_t sec : SEC_BITS;$/;"	m	struct:ppa::__anon5::__anon6
sec	ftl.h	/^    nand_sec_status_t *sec;$/;"	m	struct:nand_page
secs_per_blk	ftl.h	/^    int secs_per_blk; \/* # of sectors per block *\/$/;"	m	struct:ssdparams
secs_per_ch	ftl.h	/^    int secs_per_ch;  \/* # of sectors per channel *\/$/;"	m	struct:ssdparams
secs_per_line	ftl.h	/^    int secs_per_line;$/;"	m	struct:ssdparams
secs_per_lun	ftl.h	/^    int secs_per_lun; \/* # of sectors per LUN *\/$/;"	m	struct:ssdparams
secs_per_pg	ftl.h	/^    int secs_per_pg;  \/* # of sectors per page *\/$/;"	m	struct:ssdparams
secs_per_pl	ftl.h	/^    int secs_per_pl;  \/* # of sectors per plane *\/$/;"	m	struct:ssdparams
secsz	ftl.h	/^    int secsz;        \/* sector size in bytes *\/$/;"	m	struct:ssdparams
sector_size_bits	hmb_types.h	/^	uint8_t sector_size_bits;$/;"	m	struct:HmbSpaceMgmtCtrl
seg_id	hmb_types.h	/^	int16_t  seg_id;$/;"	m	struct:HmbSplitTable
segent_ST_host	hmb_types.h	/^	HmbHostAddr   segent_ST_host;$/;"	m	struct:HmbCtrl
segent_ST_mapped	hmb_types.h	/^	HmbMappedAddr segent_ST_mapped;$/;"	m	struct:HmbCtrl
segent_ST_size	hmb_types.h	/^	uint64_t      segent_ST_size;$/;"	m	struct:HmbCtrl
segent_bm	hmb_types.h	/^	HmbBitmap32*    segent_bm;$/;"	m	struct:HmbCtrl
segent_bm_empty	hmb_types.h	/^	int32_t       segent_bm_empty;$/;"	m	struct:HmbCtrl
segent_bm_parts_num	hmb_types.h	/^	uint32_t      segent_bm_parts_num;$/;"	m	struct:HmbCtrl
segent_bm_table	hmb_types.h	/^	HmbDLL*       segent_bm_table;$/;"	m	struct:HmbCtrl
segent_cnt	hmb_types.h	/^	uint32_t segent_cnt;$/;"	m	struct:HmbCtrl
segent_cnt_max	hmb_types.h	/^	uint32_t segent_cnt_max;$/;"	m	struct:HmbCtrl
segent_mapped_size	hmb_types.h	/^	uint64_t      segent_mapped_size;$/;"	m	struct:HmbCtrl
segent_split_mapped	hmb_types.h	/^	HmbMappedAddr *segent_split_mapped;$/;"	m	struct:HmbCtrl
segent_split_num	hmb_types.h	/^	uint16_t      segent_split_num;$/;"	m	struct:HmbCtrl
segent_split_unit	hmb_types.h	/^	uint32_t      segent_split_unit;$/;"	m	struct:HmbCtrl
segment	hmb_types.h	/^	uint32_t segment;		\/* 4bytes (acc: 4) *\/$/;"	m	struct:HmbSharedEnt
segment_id	hmb_types.h	/^	int16_t            segment_id;$/;"	m	struct:HmbSegEmpty
segment_id	hmb_types.h	/^	int16_t  segment_id; \/* 2bytes (acc: 6) *\/$/;"	m	struct:HmbSegEnt
segs	hmb_types.h	/^	struct HmbSeg*     segs;$/;"	m	struct:HmbCtrl	typeref:struct:HmbCtrl::HmbSeg
select_victim_line	ftl.c	/^static struct line *select_victim_line(struct ssd *ssd, bool force)$/;"	f	file:
set_hmb_cache	ftl.c	/^static inline void set_hmb_cache(struct ssd *ssd, int entry, int i)$/;"	f	file:
set_maptbl_ent	ftl.c	/^static inline void set_maptbl_ent(struct ssd *ssd, uint64_t lpn, struct ppa *ppa)$/;"	f	file:
set_reserved_blk	ftl.c	/^static inline void set_reserved_blk(struct ssd *ssd, struct nand_block *r_blk)$/;"	f	file:
set_rmap_ent	ftl.c	/^static inline void set_rmap_ent(struct ssd *ssd, uint64_t lpn, struct ppa *ppa)$/;"	f	file:
should_gc	ftl.c	/^static inline bool should_gc(struct ssd *ssd)$/;"	f	file:
should_gc_high	ftl.c	/^static inline bool should_gc_high(struct ssd *ssd)$/;"	f	file:
shr_read_cnt	ftl.h	/^	int32_t shr_read_cnt[4];$/;"	m	struct:ssd
shr_read_cnt	hash/hashftl.c	/^int32_t shr_read_cnt[4];$/;"	v
size	hmb_types.h	/^	uint32_t    size; \/* 4bytes (acc: 12) *\/ $/;"	m	struct:HmbEntry
size	hmb_types.h	/^	uint32_t size;       \/* 4bytes (acc: 14) *\/$/;"	m	struct:HmbSegEnt
size	hmb_types.h	/^	uint64_t size;           \/* HMB: Total memory buffer size *\/$/;"	m	struct:HmbCtrl
size_allocable_max	hmb_types.h	/^	uint64_t           size_allocable_max;$/;"	m	struct:HmbSeg
size_max	hmb_types.h	/^	uint64_t           size_max;$/;"	m	struct:HmbSeg
size_pg	hmb_types.h	/^	uint32_t size_pg;        \/* HMB: Host Memory Buffer Size (from dword 12) *\/$/;"	m	struct:HmbCtrl
sorted_ST_mapped	hmb_types.h	/^	HmbMappedAddr *sorted_ST_mapped;$/;"	m	struct:HmbSpaceMgmtCtrl
sorted_ST_size	hmb_types.h	/^	uint64_t sorted_ST_size;$/;"	m	struct:HmbSpaceMgmtCtrl
sorted_split_mapped	hmb_types.h	/^	HmbMappedAddr **sorted_split_mapped;$/;"	m	struct:HmbSpaceMgmtCtrl
sorted_split_num	hmb_types.h	/^	uint16_t sorted_split_num;$/;"	m	struct:HmbSpaceMgmtCtrl
sorted_split_unit	hmb_types.h	/^	uint32_t sorted_split_unit;$/;"	m	struct:HmbSpaceMgmtCtrl
sp	ftl.h	/^	struct ssdparams sp;$/;"	m	struct:ssd	typeref:struct:ssd::ssdparams
ssd	ftl.h	/^struct ssd {$/;"	s
ssd_advance_block_write_pointer	ftl.c	/^static void ssd_advance_block_write_pointer(struct ssd *ssd,  struct ppa *ppa)$/;"	f	file:
ssd_advance_status	ftl.c	/^uint64_t ssd_advance_status(struct ssd *ssd, struct ppa *ppa, struct$/;"	f
ssd_advance_write_pointer	ftl.c	/^static void ssd_advance_write_pointer(struct ssd *ssd)$/;"	f	file:
ssd_channel	ftl.h	/^struct ssd_channel {$/;"	s
ssd_init	ftl.c	/^void ssd_init(FemuCtrl *n)$/;"	f
ssd_init_ch	ftl.c	/^static void ssd_init_ch(struct ssd_channel *ch, struct ssdparams *spp)$/;"	f	file:
ssd_init_hash_FTL	ftl.c	/^static void ssd_init_hash_FTL(struct ssd *ssd) {$/;"	f	file:
ssd_init_hmb_cache	ftl.c	/^static void ssd_init_hmb_cache(struct ssd *ssd)$/;"	f	file:
ssd_init_lines	ftl.c	/^static void ssd_init_lines(struct ssd *ssd)$/;"	f	file:
ssd_init_maptbl	ftl.c	/^static void ssd_init_maptbl(struct ssd *ssd)$/;"	f	file:
ssd_init_nand_blk	ftl.c	/^static void ssd_init_nand_blk(struct nand_block *blk, struct ssdparams *spp, uint64_t id)$/;"	f	file:
ssd_init_nand_lun	ftl.c	/^static void ssd_init_nand_lun(struct nand_lun *lun, struct ssdparams *spp)$/;"	f	file:
ssd_init_nand_page	ftl.c	/^static void ssd_init_nand_page(struct nand_page *pg, struct ssdparams *spp)$/;"	f	file:
ssd_init_nand_plane	ftl.c	/^static void ssd_init_nand_plane(struct nand_plane *pl, struct ssdparams *spp)$/;"	f	file:
ssd_init_params	ftl.c	/^static void ssd_init_params(struct ssdparams *spp, struct ssd *ssd)$/;"	f	file:
ssd_init_rmap	ftl.c	/^static void ssd_init_rmap(struct ssd *ssd)$/;"	f	file:
ssd_init_write_pointer	ftl.c	/^static void ssd_init_write_pointer(struct ssd *ssd)$/;"	f	file:
ssd_read	ftl.c	/^static uint64_t ssd_read(struct ssd *ssd, NvmeRequest *req)$/;"	f	file:
ssd_write	ftl.c	/^static uint64_t ssd_write(struct ssd *ssd, NvmeRequest *req)$/;"	f	file:
ssdname	ftl.h	/^	char *ssdname;$/;"	m	struct:ssd
ssdparams	ftl.h	/^struct ssdparams {$/;"	s
state	ftl.h	/^	bool state; \/\/ CLEAN or DIRTY$/;"	m	struct:primary_table
state	ftl.h	/^	bool state; \/\/ CLEAN or DIRTY$/;"	m	struct:virtual_block_table
state	hash/hashftl.h	/^	bool state; \/\/ CLEAN or DIRTY$/;"	m	struct:primary_table
state	hash/hashftl.h	/^	bool state; \/\/ CLEAN or DIRTY$/;"	m	struct:virtual_block_table
status	ftl.h	/^    int status;$/;"	m	struct:nand_page
stime	ftl.h	/^    int64_t stime; \/* Coperd: request arrival time *\/$/;"	m	struct:nand_cmd
t_acc_ns	hmb_types.h	/^	uint64_t t_acc_ns;$/;"	m	struct:HmbTime
t_prev_ns	hmb_types.h	/^	uint64_t t_prev_ns;$/;"	m	struct:HmbTime
table_ST_mapped	hmb_types.h	/^	HmbMappedAddr *table_ST_mapped;$/;"	m	struct:HmbSpaceMgmtCtrl
table_ST_size	hmb_types.h	/^	uint64_t      table_ST_size;$/;"	m	struct:HmbSpaceMgmtCtrl
table_bm_ST_mapped	hmb_types.h	/^	HmbMappedAddr *table_bm_ST_mapped;$/;"	m	struct:HmbSpaceMgmtCtrl
table_bm_ST_size	hmb_types.h	/^	uint64_t      table_bm_ST_size;$/;"	m	struct:HmbSpaceMgmtCtrl
table_bm_split_mapped	hmb_types.h	/^	HmbMappedAddr **table_bm_split_mapped;$/;"	m	struct:HmbSpaceMgmtCtrl
table_cnt	hmb_types.h	/^	uint32_t table_cnt; \/* # used entries in the cache metadata list *\/$/;"	m	struct:HmbSpaceMgmtCtrl
table_cnt_max	hmb_types.h	/^	uint32_t table_cnt_max; \/* # maximum entries in the cache metadata list *\/$/;"	m	struct:HmbSpaceMgmtCtrl
table_mapped	hmb_types.h	/^	HmbMappedAddr **table_mapped;$/;"	m	struct:HmbSpaceMgmtCtrl
table_size_max	hmb_types.h	/^	uint64_t table_size_max; \/* multiple of HmbSpaceMgmtCtrl->cache_unit *\/$/;"	m	struct:HmbSpaceMgmtCtrl
table_split_mapped	hmb_types.h	/^	HmbMappedAddr **table_split_mapped;$/;"	m	struct:HmbSpaceMgmtCtrl
table_split_num	hmb_types.h	/^	uint16_t      table_split_num;$/;"	m	struct:HmbSpaceMgmtCtrl
table_split_unit	hmb_types.h	/^	uint32_t      table_split_unit;$/;"	m	struct:HmbSpaceMgmtCtrl
timer_WB	hmb_types.h	/^	QEMUTimer *timer_WB;$/;"	m	struct:HmbSpaceMgmtCtrl
to_ftl	ftl.h	/^    struct rte_ring **to_ftl;$/;"	m	struct:ssd	typeref:struct:ssd::rte_ring
to_poller	ftl.h	/^    struct rte_ring **to_poller;$/;"	m	struct:ssd	typeref:struct:ssd::rte_ring
tt_blks	ftl.h	/^    int tt_blks;      \/* total # of blocks in the SSD *\/$/;"	m	struct:ssdparams
tt_lines	ftl.h	/^    int tt_lines;$/;"	m	struct:line_mgmt
tt_lines	ftl.h	/^    int tt_lines;$/;"	m	struct:ssdparams
tt_luns	ftl.h	/^    int tt_luns;      \/* total # of LUNs in the SSD *\/$/;"	m	struct:ssdparams
tt_pgs	ftl.h	/^    int tt_pgs;       \/* total # of pages in the SSD *\/$/;"	m	struct:ssdparams
tt_pls	ftl.h	/^    int tt_pls;       \/* total # of planes in the SSD *\/$/;"	m	struct:ssdparams
tt_secs	ftl.h	/^    int tt_secs;      \/* # of sectors in the SSD *\/$/;"	m	struct:ssdparams
type	ftl.h	/^    int type;$/;"	m	struct:nand_cmd
type	hash/hashftl.h	/^	TYPE type;$/;"	m	struct:hash_params
unset_reserved_blk	ftl.c	/^static inline void unset_reserved_blk(struct ssd *ssd, struct nand_block *r_blk)$/;"	f	file:
urgency	hmb_types.h	/^	HmbMappedAddr *urgency;$/;"	m	struct:HmbSpaceMgmtCtrl
urgency	hmb_types.h	/^	uint64_t urgency:  3;$/;"	m	struct:HmbSharedEnt
usable	hmb_types.h	/^	uint64_t usable :  1;  $/;"	m	struct:HmbSharedEnt
valid_lpn	ftl.c	/^static inline bool valid_lpn(struct ssd *ssd, uint64_t lpn)$/;"	f	file:
valid_ppa	ftl.c	/^static inline bool valid_ppa(struct ssd *ssd, struct ppa *ppa)$/;"	f	file:
value	hash/hashftl.h	/^	value_set *value;$/;"	m	struct:hash_params
vbt	ftl.h	/^	VIRTUAL_BLOCK_TABLE *vbt;$/;"	m	struct:ssd
vbt	hash/hashftl.c	/^VIRTUAL_BLOCK_TABLE *vbt;$/;"	v
victimAll	hmb_types.h	/^	HmbMappedAddr *victimAll;$/;"	m	struct:HmbSpaceMgmtCtrl
victimRc	hmb_types.h	/^	HmbMappedAddr *victimRc;$/;"	m	struct:HmbSpaceMgmtCtrl
victim_line_cmp_pri	ftl.c	/^static inline int victim_line_cmp_pri(pqueue_pri_t next, pqueue_pri_t curr)$/;"	f	file:
victim_line_cnt	ftl.h	/^    int victim_line_cnt;$/;"	m	struct:line_mgmt
victim_line_get_pos	ftl.c	/^static inline size_t victim_line_get_pos(void *a)$/;"	f	file:
victim_line_get_pri	ftl.c	/^static inline pqueue_pri_t victim_line_get_pri(void *a)$/;"	f	file:
victim_line_pq	ftl.h	/^    pqueue_t *victim_line_pq;$/;"	m	struct:line_mgmt
victim_line_set_pos	ftl.c	/^static inline void victim_line_set_pos(void *a, size_t pos)$/;"	f	file:
victim_line_set_pri	ftl.c	/^static inline void victim_line_set_pri(void *a, pqueue_pri_t pri)$/;"	f	file:
virtual_block_table	ftl.h	/^typedef struct virtual_block_table{$/;"	s
virtual_block_table	hash/hashftl.h	/^typedef struct virtual_block_table{$/;"	s
vpc	ftl.h	/^    int vpc; \/* valid page count *\/$/;"	m	struct:nand_block
vpc	ftl.h	/^    int vpc; \/* valid page count in this line *\/$/;"	m	struct:line
w	hmb_types.h	/^	void *w;$/;"	m	struct:HmbMappedAddr
w_e_next	hmb_types.h	/^	uint32_t w_e_next;$/;"	m	struct:HmbSortedEnt
w_e_prev	hmb_types.h	/^	uint32_t w_e_prev;$/;"	m	struct:HmbSortedEnt
wp	ftl.h	/^	struct write_pointer wp;$/;"	m	struct:ssd	typeref:struct:ssd::write_pointer
wp	ftl.h	/^    int wp; \/* current write pointer *\/$/;"	m	struct:nand_block
wp_hash	ftl.h	/^    struct write_pointer *wp_hash;$/;"	m	struct:ssd	typeref:struct:ssd::write_pointer
write_pointer	ftl.h	/^struct write_pointer {$/;"	s
